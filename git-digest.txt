Directory structure:
â””â”€â”€ stabmbqc-game/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ git-digest.txt
    â”œâ”€â”€ ideas-log0.md
    â”œâ”€â”€ repo-digest.txt
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ cli_generate.py
    â”‚   â”œâ”€â”€ model.py
    â”‚   â”œâ”€â”€ qc-main0.py
    â”‚   â”œâ”€â”€ rendering.py
    â”‚   â””â”€â”€ rounds.py
    â””â”€â”€ docs/
        â”œâ”€â”€ README.md
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: README.md
================================================
# StabMBQC Game â€“ Stabilizer Survival

This repository contains a small web-based game built around your StabMBQC ideas.
The project is intentionally split into two main parts:

- `docs/`: a static front-end (HTML/CSS/JS) suitable for GitHub Pages.
- `backend/`: a Python package that does all the quantum/heavy lifting (Stim, Qiskit, etc.).

## Layout

```text
.
â”œâ”€â”€ docs/           # static site: index.html, JS, CSS, level JSON, assets
â””â”€â”€ backend/        # Python: Stim/Qiskit logic, level/round generation
```

## Typical workflows

### 1. Running the front-end locally

From the repo root:

```bash
python -m http.server 8000
```

Then open:

- <http://localhost:8000/docs/>

The front-end will load `docs/levels/level-1.json` and display the game.

### 2. Generating levels with Python (backend)

Use the CLI script in `backend/` to generate JSON + assets:

```bash
python -m backend.cli_generate \
  --level 1 \
  --num-rounds 5 \
  --out-json docs/levels/level-1.json \
  --assets-dir docs/assets
```

This will:

- Call into `backend.qc-main0` to generate stabilizers/candidates per round.
- Optionally render circuit/graph images (once you implement `rendering.py`).
- Produce a `level-1.json` file that the front-end can immediately use.

### 3. Where to put the quantum logic

All the physics-specific code (Stim, stabilizer reasoning, extractability checks) should
live in `backend/qc-main0.py`. The rest of the backend modules are thin wrappers that
turn your physics into front-endâ€“friendly JSON.



================================================
FILE: git-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ git-digest.txt
    â”œâ”€â”€ ideas-log0.md
    â”œâ”€â”€ repo-digest.txt
    â”œâ”€â”€ update_stabmbqc_game_slides.sh
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ cli_generate.py
    â”‚   â”œâ”€â”€ model.py
    â”‚   â”œâ”€â”€ qc-main0.py
    â”‚   â”œâ”€â”€ rendering.py
    â”‚   â””â”€â”€ rounds.py
    â””â”€â”€ docs/
        â”œâ”€â”€ README.md
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: README.md
================================================
# StabMBQC Game â€“ Stabilizer Survival

This repository contains a small web-based game built around your StabMBQC ideas.
The project is intentionally split into two main parts:

- `docs/`: a static front-end (HTML/CSS/JS) suitable for GitHub Pages.
- `backend/`: a Python package that does all the quantum/heavy lifting (Stim, Qiskit, etc.).

## Layout

```text
.
â”œâ”€â”€ docs/           # static site: index.html, JS, CSS, level JSON, assets
â””â”€â”€ backend/        # Python: Stim/Qiskit logic, level/round generation
```

## Typical workflows

### 1. Running the front-end locally

From the repo root:

```bash
python -m http.server 8000
```

Then open:

- <http://localhost:8000/docs/>

The front-end will load `docs/levels/level-1.json` and display the game.

### 2. Generating levels with Python (backend)

Use the CLI script in `backend/` to generate JSON + assets:

```bash
python -m backend.cli_generate \
  --level 1 \
  --num-rounds 5 \
  --out-json docs/levels/level-1.json \
  --assets-dir docs/assets
```

This will:

- Call into `backend.qc-main0` to generate stabilizers/candidates per round.
- Optionally render circuit/graph images (once you implement `rendering.py`).
- Produce a `level-1.json` file that the front-end can immediately use.

### 3. Where to put the quantum logic

All the physics-specific code (Stim, stabilizer reasoning, extractability checks) should
live in `backend/qc-main0.py`. The rest of the backend modules are thin wrappers that
turn your physics into front-endâ€“friendly JSON.



================================================
FILE: git-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ repo-digest.txt
    â”œâ”€â”€ update_stabmbqc_game_slides.sh
    â”œâ”€â”€ backend/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ cli_generate.py
    â”‚   â”œâ”€â”€ model.py
    â”‚   â”œâ”€â”€ qc-main0.py
    â”‚   â”œâ”€â”€ rendering.py
    â”‚   â””â”€â”€ rounds.py
    â””â”€â”€ docs/
        â”œâ”€â”€ README.md
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: README.md
================================================
# StabMBQC Game â€“ Stabilizer Survival

This repository contains a small web-based game built around your StabMBQC ideas.
The project is intentionally split into two main parts:

- `docs/`: a static front-end (HTML/CSS/JS) suitable for GitHub Pages.
- `backend/`: a Python package that does all the quantum/heavy lifting (Stim, Qiskit, etc.).

## Layout

```text
.
â”œâ”€â”€ docs/           # static site: index.html, JS, CSS, level JSON, assets
â””â”€â”€ backend/        # Python: Stim/Qiskit logic, level/round generation
```

## Typical workflows

### 1. Running the front-end locally

From the repo root:

```bash
python -m http.server 8000
```

Then open:

- <http://localhost:8000/docs/>

The front-end will load `docs/levels/level-1.json` and display the game.

### 2. Generating levels with Python (backend)

Use the CLI script in `backend/` to generate JSON + assets:

```bash
python -m backend.cli_generate \
  --level 1 \
  --num-rounds 5 \
  --out-json docs/levels/level-1.json \
  --assets-dir docs/assets
```

This will:

- Call into `backend.qc-main0` to generate stabilizers/candidates per round.
- Optionally render circuit/graph images (once you implement `rendering.py`).
- Produce a `level-1.json` file that the front-end can immediately use.

### 3. Where to put the quantum logic

All the physics-specific code (Stim, stabilizer reasoning, extractability checks) should
live in `backend/qc-main0.py`. The rest of the backend modules are thin wrappers that
turn your physics into front-endâ€“friendly JSON.



================================================
FILE: repo-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â”œâ”€â”€ repo-digest.txt
    â”œâ”€â”€ update_stabmbqc_game_slides.sh
    â””â”€â”€ docs/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: repo-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â””â”€â”€ docs/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Intro screen -->
  <div id="intro-screen">
    <div id="intro-content">
      <h1>Stabilizer Survival</h1>
      <p>
        Alice has an encoded stabilizer state <span class="mathlike">|ğ’®, ÏˆâŸ©</span>. 
        Charlie is secretly on her side, but is forced by Bob to perform a Pauli measurement each round.
      </p>
      <p>
        Your task: in each round, choose a Pauli measurement that is <strong>safe</strong> â€“ it should anticommute with at least one stabilizer generator, so it only updates the stabilizer and does not measure a logical operator.
      </p>
      <p class="small-note">
        Level 1: no fancy unitaries yet. This is pure stabilizer intuition training.
      </p>
      <button id="start-btn">Start Level 1</button>
    </div>
  </div>

  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="round-progress"></div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="next-level-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// ==========================
// Level loading & rendering
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }
}

// ==========================
// Interaction handlers
// ==========================

function handleCandidateClick(candidate, round) {
  const pauli = candidate.pauli;
  const stabs = round.stabilizers;

  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers here (in this toy level), so we treat it as measuring a logical operator. Your encoded state would be damaged.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // force reflow so animation can restart
      leftPanel.classList.add("shake");
    }
  }

  if (!hasAnsweredThisRound) {
    hasAnsweredThisRound = true;
    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", () => {
  console.log("DOM fully loaded, wiring up handlersâ€¦");

  const startBtn = $("#start-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const introScreen = $("#intro-screen");
  const gameContainer = $("#game-container");

  if (!startBtn) {
    console.error("start-btn not found in DOM");
    return;
  }

  startBtn.addEventListener("click", async () => {
    console.log("Start button clicked");
    if (introScreen) introScreen.classList.add("hidden");
    if (gameContainer) gameContainer.classList.remove("hidden");

    try {
      const level = await loadLevel("level-1");
      renderLevel(level);
    } catch (err) {
      console.error("Error loading level:", err);
      const levelTitleEl = $("#game-level");
      const levelDescEl = $("#level-description");
      if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
      if (levelDescEl) levelDescEl.textContent = String(err);
    }
  });

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Coming soon!)");
    });
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease;
}

.candidate-btn:hover {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active {
  transform: translateY(1px);
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Intro screen */

#intro-screen {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#intro-content {
  max-width: 600px;
  background: rgba(15, 23, 42, 0.95);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#intro-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#intro-content p {
  font-size: 0.95rem;
  line-height: 1.4;
}

#intro-content .small-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 8px;
}

.mathlike {
  font-family: "JetBrains Mono", "Fira Code", monospace;
}

#start-btn {
  margin-top: 12px;
  padding: 8px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

#start-btn:hover {
  background: #4338ca;
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "In each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Warm-up: 3-qubit chain code. Only one of these is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ],
      "graphImage": "assets/level-1-round1-graph.png",
      "circuitImage": "assets/level-1-round1-circuit.png"
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Same code, but now Charlie targets the middle qubit.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ],
      "graphImage": "assets/level-1-round2-graph.png",
      "circuitImage": "assets/level-1-round2-circuit.png"
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "A slightly more evil set of options. Think about which ones are likely logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ],
      "graphImage": "assets/level-1-round3-graph.png",
      "circuitImage": "assets/level-1-round3-circuit.png"
    }
  ]
}





================================================
FILE: update_stabmbqc_game_slides.sh
================================================
#!/usr/bin/env bash
set -e

PROJECT_DIR="stabmbqc-game"

if [ ! -d "$PROJECT_DIR/docs" ]; then
  echo "Could not find $PROJECT_DIR/docs. Run this script from the parent directory of stabmbqc-game."
  exit 1
fi

cd "$PROJECT_DIR"

mkdir -p docs/levels
mkdir -p docs/assets

echo "Updating docs/index.html..."
cat > docs/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
        <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
          Start level
        </button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>
EOF

echo "Updating docs/style.css..."
cat > docs/style.css << 'EOF'
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Buttons used in slides */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}
EOF

echo "Updating docs/main.js..."
cat > docs/main.js << 'EOF'
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    // nothing to show
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    // done
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  // start timer for this round
  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // restart animation
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      // finishing slides explicitly from button
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartBtn) {
    restartBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  try {
    const level = await loadLevel("level-1");
    // show slides first, then start the level
    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level);
    };
    if (level.introSlides && level.introSlides.length > 0) {
      showSlides(level.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});
EOF

echo "Updating docs/levels/level-1.json..."
cat > docs/levels/level-1.json << 'EOF'
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}
EOF

echo "Done. Now run:"
echo "  cd $PROJECT_DIR"
echo "  python -m http.server 8000"
echo "and open http://localhost:8000/docs/ in your browser."
EOF

---

## 2. How to use it

From the folder **above** `stabmbqc-game/`:

```bash
chmod +x update_stabmbqc_game_slides.sh
./update_stabmbqc_game_slides.sh



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <div id="slides-left-buttons">
          <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
          <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        </div>
        <div id="slides-right-buttons">
          <button id="slide-skip-btn" class="secondary-btn">Skip intro</button>
          <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
            Start level
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules / info overlay -->
  <div id="info-overlay" class="hidden">
    <div id="info-content">
      <h1>Game Guidelines (Dummy)</h1>
      <ul>
        <li>You play as Alice, protecting a logical qubit encoded in a stabilizer code.</li>
        <li>Each round, Charlie must perform one Pauli measurement. You choose which one.</li>
        <li>Safe choice: a Pauli that anticommutes with at least one stabilizer generator (it only reshuffles stabilizers).</li>
        <li>Unsafe choice: treated here as a logical measurement â€“ it collapses the logical state and ends the level.</li>
        <li>You only have a limited time each round. If the timer hits zero, the hacker wins that round.</li>
      </ul>
      <p class="info-note">In the real version, this page will also show the key math rules and diagrams.</p>
      <div id="info-controls">
        <button id="info-close-btn" class="primary-btn">Back to game</button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
        <div id="header-buttons">
          <button id="rules-btn" class="secondary-btn header-btn">Rules</button>
          <button id="restart-game-btn" class="secondary-btn header-btn">Restart game â†»</button>
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  return true;
}

function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let level1Data = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;
let timerPaused = false;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Info overlay
// ==========================

function showInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  // pause timer if running
  if (!hasAnsweredThisRound && remainingSeconds > 0 && roundTimerId !== null) {
    clearRoundTimer();
    timerPaused = true;
  } else {
    timerPaused = false;
  }

  infoOverlay.classList.remove("hidden");
}

function hideInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  infoOverlay.classList.add("hidden");

  if (timerPaused && !hasAnsweredThisRound && remainingSeconds > 0) {
    startRoundTimer(remainingSeconds);
  }
  timerPaused = false;
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth;
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

function restartGame() {
  clearRoundTimer();
  hasAnsweredThisRound = false;
  currentRoundIndex = 0;
  const gameContainer = $("#game-container");
  if (gameContainer) gameContainer.classList.add("hidden");

  const onSlidesDone = () => {
    if (gameContainer) gameContainer.classList.remove("hidden");
    if (level1Data) {
      renderLevel(level1Data);
    }
  };

  if (level1Data && level1Data.introSlides && level1Data.introSlides.length > 0) {
    showSlides(level1Data.introSlides, onSlidesDone);
  } else {
    hideSlides();
    onSlidesDone();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const slidesSkipBtn = $("#slide-skip-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartLevelBtn = $("#restart-level-btn");
  const restartGameBtn = $("#restart-game-btn");
  const rulesBtn = $("#rules-btn");
  const infoCloseBtn = $("#info-close-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (slidesSkipBtn) {
    slidesSkipBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartLevelBtn) {
    restartLevelBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      restartGame();
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () => {
      showInfoOverlay();
    });
  }

  if (infoCloseBtn) {
    infoCloseBtn.addEventListener("click", () => {
      hideInfoOverlay();
    });
  }

  try {
    const level = await loadLevel("level-1");
    level1Data = level;

    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level1Data);
    };

    if (level1Data.introSlides && level1Data.introSlides.length > 0) {
      showSlides(level1Data.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

#header-buttons {
  display: flex;
  gap: 6px;
}

.header-btn {
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Info overlay */

#info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.94);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 60;
}

#info-content {
  max-width: 700px;
  width: 90%;
  background: #020617;
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 40px rgba(0,0,0,0.7);
}

#info-content h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

#info-content ul {
  margin-top: 8px;
  padding-left: 20px;
}

#info-content li {
  margin-bottom: 4px;
  font-size: 0.95rem;
}

.info-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 6px;
}

#info-controls {
  margin-top: 10px;
  text-align: right;
}

/* Buttons used in slides and overlays */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}





================================================
FILE: update_stabmbqc_game_slides.sh
================================================
#!/usr/bin/env bash
set -e

PROJECT_DIR="stabmbqc-game"

if [ ! -d "$PROJECT_DIR/docs" ]; then
  echo "Could not find $PROJECT_DIR/docs. Run this script from the parent directory of stabmbqc-game."
  exit 1
fi

cd "$PROJECT_DIR"

mkdir -p docs/levels
mkdir -p docs/assets

echo "Updating docs/index.html..."
cat > docs/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
        <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
          Start level
        </button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>
EOF

echo "Updating docs/style.css..."
cat > docs/style.css << 'EOF'
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Buttons used in slides */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}
EOF

echo "Updating docs/main.js..."
cat > docs/main.js << 'EOF'
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    // nothing to show
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    // done
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  // start timer for this round
  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // restart animation
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      // finishing slides explicitly from button
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartBtn) {
    restartBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  try {
    const level = await loadLevel("level-1");
    // show slides first, then start the level
    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level);
    };
    if (level.introSlides && level.introSlides.length > 0) {
      showSlides(level.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});
EOF

echo "Updating docs/levels/level-1.json..."
cat > docs/levels/level-1.json << 'EOF'
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}
EOF

echo "Done. Now run:"
echo "  cd $PROJECT_DIR"
echo "  python -m http.server 8000"
echo "and open http://localhost:8000/docs/ in your browser."
EOF

---

## 2. How to use it

From the folder **above** `stabmbqc-game/`:

```bash
chmod +x update_stabmbqc_game_slides.sh
./update_stabmbqc_game_slides.sh



================================================
FILE: backend/README.md
================================================
# backend/ â€“ Quantum Engine for the StabMBQC Game

This package contains the Python side of the project: all the quantum logic,
Stim/Qiskit integration, and level/round generation.

## Main modules

- `qc-main0.py` â€“ **the main physics module**.
  - Put your stabilizer code, Stim circuits/tableaux, Pauli-rotation logic, and
    extractability checks here.
- `model.py` â€“ dataclasses representing candidates, rounds, and levels.
- `rendering.py` â€“ helpers to render circuit/graph images (to be implemented).
- `rounds.py` â€“ high-level glue: turns physics results into `RoundSpec` objects
  and calls the rendering helpers.
- `cli_generate.py` â€“ a small CLI tool to generate level JSON + assets.

## Example: generating one round (Python only)

You can work purely in Python while prototyping the physics.
For example, from a Python shell:

```python
from pathlib import Path
from backend.rounds import build_round

assets_dir = Path("docs/assets")
round_spec = build_round(level=1, round_index=0, assets_dir=assets_dir)

print("Num qubits:", round_spec.num_qubits)
print("Stabilizers:", round_spec.stabilizers)
for c in round_spec.candidates:
    print("Candidate:", c.label, "(pauli =", c.pauli + ")")
```

## Example: generating a full level JSON

Use the CLI helper from the repo root:

```bash
python -m backend.cli_generate \
  --level 1 \
  --num-rounds 5 \
  --out-json docs/levels/level-1.json \
  --assets-dir docs/assets
```

This will:

1. Call `build_round` `num-rounds` times.
2. Create a `LevelSpec` bundling all rounds and some dummy intro slides.
3. Write the JSON file expected by `docs/main.js`.

Once you plug in your actual Stim/Qiskit logic into `qc-main0.py` and
`rendering.py`, the front-end will instantly reflect the richer physics.



================================================
FILE: backend/__init__.py
================================================
"""Backend package for the StabMBQC game.

This package is responsible for generating level/round data
and doing all quantum/stabilizer/stim logic.

Typical responsibilities:
- Construct Alice's stabilizer code.
- Apply Bob's CZ + Pauli-rotation attacks.
- Use Stim (and optionally Qiskit) to compute updated stabilizers.
- Propose candidate Pauli measurements and label which are safe.
- Render circuit/graph images for the front-end.
"""



================================================
FILE: backend/cli_generate.py
================================================
"""Command-line tool to generate level JSON + assets.

Example usage:

    python -m backend.cli_generate --level 1 --num-rounds 5 \
        --out-json docs/levels/level-1.json \
        --assets-dir docs/assets
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
import random

from .model import LevelSpec, RoundSpec, to_json_dict
from .rounds import build_round


def build_dummy_intro_slides() -> list[dict]:
  """Return a small list of intro slides as Python dicts.

  You can later move this to a dedicated config file or generate it programmatically.
  """

  return [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice's logical qubit is encoded in a stabilizer code. Bob attacks via CZ and Pauli rotations.",
    },
    {
      "title": "Your task",
      "text": "In each round, choose a Pauli measurement that keeps the logical information safe.",
    },
  ]


def main() -> None:
  parser = argparse.ArgumentParser()
  parser.add_argument("--level", type=int, default=1, help="Level number (e.g. 1)")
  parser.add_argument("--num-rounds", type=int, default=3, help="Number of rounds to generate")
  parser.add_argument("--out-json", type=Path, default=Path("docs/levels/level-1.json"))
  parser.add_argument("--assets-dir", type=Path, default=Path("docs/assets"))
  parser.add_argument("--seed", type=int, default=42)

  args = parser.parse_args()

  rng = random.Random(args.seed)
  assets_dir = args.assets_dir
  assets_dir.mkdir(parents=True, exist_ok=True)

  rounds: list[RoundSpec] = []
  for i in range(args.num_rounds):
    round_spec = build_round(level=args.level, round_index=i, assets_dir=assets_dir)
    rounds.append(round_spec)

  level_spec = LevelSpec(
    id=f"level-{args.level}",
    title=f"Level {args.level} â€“ Autogenerated",
    description="Level generated by backend.cli_generate.",
    round_time_limit_seconds=15,
    intro_slides=build_dummy_intro_slides(),
    rounds=rounds,
  )

  args.out_json.parent.mkdir(parents=True, exist_ok=True)
  with args.out_json.open("w", encoding="utf-8") as f:
    json.dump(to_json_dict(level_spec), f, indent=2)

  print(f"Wrote level JSON to {args.out_json}")
  print(f"Assets directory: {assets_dir}")


if __name__ == "__main__":  # pragma: no cover
  main()



================================================
FILE: backend/model.py
================================================
"""Typed models for level and round data.

These mirror (roughly) the JSON structure consumed by the front-end.
"""

from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import List, Optional, Dict, Any


@dataclass
class Candidate:
  label: str
  pauli: str


@dataclass
class RoundSpec:
  id: int
  label: str
  text: str
  num_qubits: int
  stabilizers: List[str]
  candidates: List[Candidate]
  graph_image: Optional[str] = None
  circuit_image: Optional[str] = None


@dataclass
class LevelSpec:
  id: str
  title: str
  description: str
  round_time_limit_seconds: int
  intro_slides: List[Dict[str, Any]]
  rounds: List[RoundSpec]


def to_json_dict(level: LevelSpec) -> Dict[str, Any]:
  """Convert a LevelSpec into a JSON-serializable dict."""
  return asdict(level)



================================================
FILE: backend/qc-main0.py
================================================
"""Main quantum logic for the StabMBQC game.

This is where you put the real physics:
- Stim tableaux and circuits
- stabilizer updates under CZ and Pauli rotations
- extractability checks for Level 2

The rest of the backend modules should call into functions defined here.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List

# NOTE: import Stim/Qiskit here once installed, e.g.:
# import stim
# from qiskit import QuantumCircuit


@dataclass
class Candidate:
  """A candidate Pauli measurement offered to the player.

  label: human-readable with spaces, e.g. "Z I X I"
  pauli: compact form for the backend/frontend, e.g. "ZIXI"
  """

  label: str
  pauli: str


@dataclass
class RoundPhysicsResult:
  """Container for the raw physics result of one round.

  This is intentionally backend-facing and can be richer than what the
  front-end sees; `rounds.py` can convert it into the JSON-friendly
  structure used by the game.
  """

  num_qubits: int
  stabilizers: List[str]
  candidates: List[Candidate]
  # You can add more fields later, e.g. tableau, attack description, etc.


def generate_round_physics(level: int, round_index: int) -> RoundPhysicsResult:
  """Stub for the main physics generator for a single round.

  This is where you'll:
  - build Alice's code (using Stim/tableaux),
  - apply Bob's CZ + rotations,
  - compute the updated stabilizers,
  - generate candidate Pauli measurements and decide which are safe.

  For now this just returns a tiny dummy example; replace with real logic.
  """

  # TODO: replace this with Stim/Qiskit-based generation.
  num_qubits = 3
  stabilizers = ["ZZI", "IZZ"]
  candidates = [
    Candidate(label="Z I I", pauli="ZII"),
    Candidate(label="X I I", pauli="XII"),
    Candidate(label="X X X", pauli="XXX"),
  ]

  return RoundPhysicsResult(
    num_qubits=num_qubits,
    stabilizers=stabilizers,
    candidates=candidates,
  )



================================================
FILE: backend/rendering.py
================================================
"""Rendering helpers: circuit and graph images.

The real implementation should:
- take the internal description of Bob's attack / Alice's code,
- build a Qiskit (or Stimâ†’Qiskit) circuit,
- draw a PNG/SVG and save it into docs/assets/.

For now we just stub out the functions; you can fill them in as you go.
"""

from __future__ import annotations

from pathlib import Path


def render_circuit_png(attack_description, out_path: Path) -> str:
  """Render a circuit image and return its *relative* path for JSON.

  Parameters
  ----------
  attack_description: Any
      Whatever structure you decide to use to describe the CZ/rotation attack.
  out_path: Path
      Absolute or repo-root-relative path where the PNG will be written.
  """

  # TODO: implement with Qiskit once you wire up the circuits.
  out_path.parent.mkdir(parents=True, exist_ok=True)
  # For now you might write a placeholder PNG or leave it absent.

  # Return a path relative to docs/, e.g. "assets/level1-round01-circuit.png".
  return str(out_path)


def render_graph_png(graph_description, out_path: Path) -> str:
  """Render a graph image (e.g. code connectivity) and return relative path.

  Parameters
  ----------
  graph_description: Any
      Your preferred representation of the stabilizer graph / lattice.
  out_path: Path
      Where to save the graph image.
  """

  # TODO: implement using networkx/matplotlib if you want graph visuals.
  out_path.parent.mkdir(parents=True, exist_ok=True)
  return str(out_path)



================================================
FILE: backend/rounds.py
================================================
"""High-level round construction.

This module glues together:
- the low-level physics in qc-main0.py
- the typed models in model.py
- the rendering helpers in rendering.py

so that you can easily generate LevelSpec instances and dump them to JSON.
"""

from __future__ import annotations

from pathlib import Path
from typing import List

from . import qc-main0 as qc
from .model import Candidate, RoundSpec
from .rendering import render_circuit_png, render_graph_png


def build_round(
  level: int,
  round_index: int,
  assets_dir: Path,
) -> RoundSpec:
  """Create a RoundSpec for the given level/round index.

  This function:
  - calls into the physics layer (qc-main0) to generate stabilizers/candidates,
  - optionally renders circuit/graph images,
  - wraps everything into a RoundSpec.
  """

  physics_result = qc.generate_round_physics(level=level, round_index=round_index)

  circuit_name = f"level{level}-round{round_index:02d}-circuit.png"
  graph_name = f"level{level}-round{round_index:02d}-graph.png"

  circuit_path = assets_dir / circuit_name
  graph_path = assets_dir / graph_name

  circuit_rel = render_circuit_png(attack_description=None, out_path=circuit_path)
  graph_rel = render_graph_png(graph_description=None, out_path=graph_path)

  candidates: List[Candidate] = [
    Candidate(label=c.label, pauli=c.pauli) for c in physics_result.candidates
  ]

  text = "Auto-generated round (dummy text for now)."

  return RoundSpec(
    id=round_index,
    label=f"Round {round_index + 1}",
    text=text,
    num_qubits=physics_result.num_qubits,
    stabilizers=physics_result.stabilizers,
    candidates=candidates,
    graph_image=str(graph_rel),
    circuit_image=str(circuit_rel),
  )



================================================
FILE: docs/README.md
================================================
# docs/ â€“ Front-end for the StabMBQC Game

This directory contains the static assets for the "Stabilizer Survival" game.
It is suitable for hosting on GitHub Pages.

## Key files

- `index.html` â€“ main HTML file, includes the slide engine and game UI.
- `style.css` â€“ styling for slides, game layout, buttons, etc.
- `main.js` â€“ front-end logic:
  - loads level JSON (e.g. `levels/level-1.json`),
  - shows intro slides, handles timers,
  - renders stabilizers, circuit/graph images,
  - checks answers client-side.
- `levels/` â€“ JSON level descriptions generated by the backend.
- `assets/` â€“ images (circuit diagrams, graphs, etc.).

## Running locally

From the **repo root**, run:

```bash
python -m http.server 8000
```

Then open:

- <http://localhost:8000/docs/>

## JSON shape expected by the front-end

Each level JSON looks roughly like this:

```json
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "...",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    { "title": "Welcome", "text": "..." },
    { "title": "Your task", "text": "..." }
  ],
  "rounds": [
    {
      "id": 0,
      "label": "Round 1",
      "text": "...",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" }
      ],
      "graphImage": "assets/level1-round00-graph.png",
      "circuitImage": "assets/level1-round00-circuit.png"
    }
  ]
}
```

The front-end does **not** care how this JSON was produced; as long as the
structure matches, it will display the level correctly.



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <div id="slides-left-buttons">
          <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
          <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        </div>
        <div id="slides-right-buttons">
          <button id="slide-skip-btn" class="secondary-btn">Skip intro</button>
          <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
            Start level
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules / info overlay -->
  <div id="info-overlay" class="hidden">
    <div id="info-content">
      <h1>Game Guidelines (Dummy)</h1>
      <ul>
        <li>You play as Alice, protecting a logical qubit encoded in a stabilizer code.</li>
        <li>Each round, Charlie must perform one Pauli measurement. You choose which one.</li>
        <li>Safe choice: a Pauli that anticommutes with at least one stabilizer generator (it only reshuffles stabilizers).</li>
        <li>Unsafe choice: treated here as a logical measurement â€“ it collapses the logical state and ends the level.</li>
        <li>You only have a limited time each round. If the timer hits zero, the hacker wins that round.</li>
      </ul>
      <p class="info-note">In the real version, this page will also show the key math rules and diagrams.</p>
      <div id="info-controls">
        <button id="info-close-btn" class="primary-btn">Back to game</button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
        <div id="header-buttons">
          <button id="rules-btn" class="secondary-btn header-btn">Rules</button>
          <button id="restart-game-btn" class="secondary-btn header-btn">Restart game â†»</button>
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  return true;
}

function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let level1Data = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;
let timerPaused = false;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Info overlay
// ==========================

function showInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  // pause timer if running
  if (!hasAnsweredThisRound && remainingSeconds > 0 && roundTimerId !== null) {
    clearRoundTimer();
    timerPaused = true;
  } else {
    timerPaused = false;
  }

  infoOverlay.classList.remove("hidden");
}

function hideInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  infoOverlay.classList.add("hidden");

  if (timerPaused && !hasAnsweredThisRound && remainingSeconds > 0) {
    startRoundTimer(remainingSeconds);
  }
  timerPaused = false;
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth;
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

function restartGame() {
  clearRoundTimer();
  hasAnsweredThisRound = false;
  currentRoundIndex = 0;
  const gameContainer = $("#game-container");
  if (gameContainer) gameContainer.classList.add("hidden");

  const onSlidesDone = () => {
    if (gameContainer) gameContainer.classList.remove("hidden");
    if (level1Data) {
      renderLevel(level1Data);
    }
  };

  if (level1Data && level1Data.introSlides && level1Data.introSlides.length > 0) {
    showSlides(level1Data.introSlides, onSlidesDone);
  } else {
    hideSlides();
    onSlidesDone();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const slidesSkipBtn = $("#slide-skip-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartLevelBtn = $("#restart-level-btn");
  const restartGameBtn = $("#restart-game-btn");
  const rulesBtn = $("#rules-btn");
  const infoCloseBtn = $("#info-close-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (slidesSkipBtn) {
    slidesSkipBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartLevelBtn) {
    restartLevelBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      restartGame();
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () => {
      showInfoOverlay();
    });
  }

  if (infoCloseBtn) {
    infoCloseBtn.addEventListener("click", () => {
      hideInfoOverlay();
    });
  }

  try {
    const level = await loadLevel("level-1");
    level1Data = level;

    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level1Data);
    };

    if (level1Data.introSlides && level1Data.introSlides.length > 0) {
      showSlides(level1Data.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

#header-buttons {
  display: flex;
  gap: 6px;
}

.header-btn {
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Info overlay */

#info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.94);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 60;
}

#info-content {
  max-width: 700px;
  width: 90%;
  background: #020617;
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 40px rgba(0,0,0,0.7);
}

#info-content h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

#info-content ul {
  margin-top: 8px;
  padding-left: 20px;
}

#info-content li {
  margin-bottom: 4px;
  font-size: 0.95rem;
}

.info-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 6px;
}

#info-controls {
  margin-top: 10px;
  text-align: right;
}

/* Buttons used in slides and overlays */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}





================================================
FILE: ideas-log0.md
================================================
# Ideas & Progress Log

A running, timeâ€‘stamped record of major steps, design choices, and structural changes in the StabMBQC Game project.

---

## 2025â€‘12â€‘05 â€” Initial Game Engine Architecture

* Designed core browser game loop: **slides â†’ level â†’ rounds â†’ next level**.
* Implemented: intro slides, skip button, rules overlay, restartâ€‘game + restartâ€‘level logic.
* Added timed rounds, perâ€‘round success/fail feedback, safe/unsafe detection.
* Separated backâ€‘end logic into JSONâ€‘driven round specifications.

## 2025â€‘12â€‘05 â€” Backend Architecture Plan (Python)

* Defined clean separation: `docs/` (frontend) vs `backend/` (quantum engine).
* Decided backend generates **JSON + assets** for levels.
* Created proposed modules: `qc-main0.py`, `model.py`, `rounds.py`, `rendering.py`, `cli_generate.py`.
* Clarified workflow for Levelâ€‘1 and Levelâ€‘2 physics (CZs, Pauli rotations, Stim tableau updates, etc.).

## 2025â€‘12â€‘05 â€” Repo Bootstrap Script

* Wrote full bash script that:

  * Autoâ€‘creates backend package structure.
  * Injects Python stubs + READMEs.
  * Defines example CLI tool and placeholder rendering functions.
* Updated READMEs for project root, docs/, backend/.
* Prepared repo for Stim/Qiskit integration.

---

*(Use the command **UPDATE LOG** anytime to append new entries automatically.)*



================================================
FILE: repo-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â”œâ”€â”€ repo-digest.txt
    â”œâ”€â”€ update_stabmbqc_game_slides.sh
    â””â”€â”€ docs/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: repo-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â””â”€â”€ docs/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Intro screen -->
  <div id="intro-screen">
    <div id="intro-content">
      <h1>Stabilizer Survival</h1>
      <p>
        Alice has an encoded stabilizer state <span class="mathlike">|ğ’®, ÏˆâŸ©</span>. 
        Charlie is secretly on her side, but is forced by Bob to perform a Pauli measurement each round.
      </p>
      <p>
        Your task: in each round, choose a Pauli measurement that is <strong>safe</strong> â€“ it should anticommute with at least one stabilizer generator, so it only updates the stabilizer and does not measure a logical operator.
      </p>
      <p class="small-note">
        Level 1: no fancy unitaries yet. This is pure stabilizer intuition training.
      </p>
      <button id="start-btn">Start Level 1</button>
    </div>
  </div>

  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="round-progress"></div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="next-level-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// ==========================
// Level loading & rendering
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }
}

// ==========================
// Interaction handlers
// ==========================

function handleCandidateClick(candidate, round) {
  const pauli = candidate.pauli;
  const stabs = round.stabilizers;

  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers here (in this toy level), so we treat it as measuring a logical operator. Your encoded state would be damaged.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // force reflow so animation can restart
      leftPanel.classList.add("shake");
    }
  }

  if (!hasAnsweredThisRound) {
    hasAnsweredThisRound = true;
    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", () => {
  console.log("DOM fully loaded, wiring up handlersâ€¦");

  const startBtn = $("#start-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const introScreen = $("#intro-screen");
  const gameContainer = $("#game-container");

  if (!startBtn) {
    console.error("start-btn not found in DOM");
    return;
  }

  startBtn.addEventListener("click", async () => {
    console.log("Start button clicked");
    if (introScreen) introScreen.classList.add("hidden");
    if (gameContainer) gameContainer.classList.remove("hidden");

    try {
      const level = await loadLevel("level-1");
      renderLevel(level);
    } catch (err) {
      console.error("Error loading level:", err);
      const levelTitleEl = $("#game-level");
      const levelDescEl = $("#level-description");
      if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
      if (levelDescEl) levelDescEl.textContent = String(err);
    }
  });

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Coming soon!)");
    });
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease;
}

.candidate-btn:hover {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active {
  transform: translateY(1px);
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Intro screen */

#intro-screen {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#intro-content {
  max-width: 600px;
  background: rgba(15, 23, 42, 0.95);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#intro-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#intro-content p {
  font-size: 0.95rem;
  line-height: 1.4;
}

#intro-content .small-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 8px;
}

.mathlike {
  font-family: "JetBrains Mono", "Fira Code", monospace;
}

#start-btn {
  margin-top: 12px;
  padding: 8px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

#start-btn:hover {
  background: #4338ca;
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "In each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Warm-up: 3-qubit chain code. Only one of these is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ],
      "graphImage": "assets/level-1-round1-graph.png",
      "circuitImage": "assets/level-1-round1-circuit.png"
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Same code, but now Charlie targets the middle qubit.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ],
      "graphImage": "assets/level-1-round2-graph.png",
      "circuitImage": "assets/level-1-round2-circuit.png"
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "A slightly more evil set of options. Think about which ones are likely logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ],
      "graphImage": "assets/level-1-round3-graph.png",
      "circuitImage": "assets/level-1-round3-circuit.png"
    }
  ]
}





================================================
FILE: update_stabmbqc_game_slides.sh
================================================
#!/usr/bin/env bash
set -e

PROJECT_DIR="stabmbqc-game"

if [ ! -d "$PROJECT_DIR/docs" ]; then
  echo "Could not find $PROJECT_DIR/docs. Run this script from the parent directory of stabmbqc-game."
  exit 1
fi

cd "$PROJECT_DIR"

mkdir -p docs/levels
mkdir -p docs/assets

echo "Updating docs/index.html..."
cat > docs/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
        <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
          Start level
        </button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>
EOF

echo "Updating docs/style.css..."
cat > docs/style.css << 'EOF'
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Buttons used in slides */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}
EOF

echo "Updating docs/main.js..."
cat > docs/main.js << 'EOF'
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    // nothing to show
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    // done
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  // start timer for this round
  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // restart animation
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      // finishing slides explicitly from button
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartBtn) {
    restartBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  try {
    const level = await loadLevel("level-1");
    // show slides first, then start the level
    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level);
    };
    if (level.introSlides && level.introSlides.length > 0) {
      showSlides(level.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});
EOF

echo "Updating docs/levels/level-1.json..."
cat > docs/levels/level-1.json << 'EOF'
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}
EOF

echo "Done. Now run:"
echo "  cd $PROJECT_DIR"
echo "  python -m http.server 8000"
echo "and open http://localhost:8000/docs/ in your browser."
EOF

---

## 2. How to use it

From the folder **above** `stabmbqc-game/`:

```bash
chmod +x update_stabmbqc_game_slides.sh
./update_stabmbqc_game_slides.sh



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <div id="slides-left-buttons">
          <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
          <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        </div>
        <div id="slides-right-buttons">
          <button id="slide-skip-btn" class="secondary-btn">Skip intro</button>
          <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
            Start level
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules / info overlay -->
  <div id="info-overlay" class="hidden">
    <div id="info-content">
      <h1>Game Guidelines (Dummy)</h1>
      <ul>
        <li>You play as Alice, protecting a logical qubit encoded in a stabilizer code.</li>
        <li>Each round, Charlie must perform one Pauli measurement. You choose which one.</li>
        <li>Safe choice: a Pauli that anticommutes with at least one stabilizer generator (it only reshuffles stabilizers).</li>
        <li>Unsafe choice: treated here as a logical measurement â€“ it collapses the logical state and ends the level.</li>
        <li>You only have a limited time each round. If the timer hits zero, the hacker wins that round.</li>
      </ul>
      <p class="info-note">In the real version, this page will also show the key math rules and diagrams.</p>
      <div id="info-controls">
        <button id="info-close-btn" class="primary-btn">Back to game</button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
        <div id="header-buttons">
          <button id="rules-btn" class="secondary-btn header-btn">Rules</button>
          <button id="restart-game-btn" class="secondary-btn header-btn">Restart game â†»</button>
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  return true;
}

function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let level1Data = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;
let timerPaused = false;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Info overlay
// ==========================

function showInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  // pause timer if running
  if (!hasAnsweredThisRound && remainingSeconds > 0 && roundTimerId !== null) {
    clearRoundTimer();
    timerPaused = true;
  } else {
    timerPaused = false;
  }

  infoOverlay.classList.remove("hidden");
}

function hideInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  infoOverlay.classList.add("hidden");

  if (timerPaused && !hasAnsweredThisRound && remainingSeconds > 0) {
    startRoundTimer(remainingSeconds);
  }
  timerPaused = false;
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth;
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

function restartGame() {
  clearRoundTimer();
  hasAnsweredThisRound = false;
  currentRoundIndex = 0;
  const gameContainer = $("#game-container");
  if (gameContainer) gameContainer.classList.add("hidden");

  const onSlidesDone = () => {
    if (gameContainer) gameContainer.classList.remove("hidden");
    if (level1Data) {
      renderLevel(level1Data);
    }
  };

  if (level1Data && level1Data.introSlides && level1Data.introSlides.length > 0) {
    showSlides(level1Data.introSlides, onSlidesDone);
  } else {
    hideSlides();
    onSlidesDone();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const slidesSkipBtn = $("#slide-skip-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartLevelBtn = $("#restart-level-btn");
  const restartGameBtn = $("#restart-game-btn");
  const rulesBtn = $("#rules-btn");
  const infoCloseBtn = $("#info-close-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (slidesSkipBtn) {
    slidesSkipBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartLevelBtn) {
    restartLevelBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      restartGame();
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () => {
      showInfoOverlay();
    });
  }

  if (infoCloseBtn) {
    infoCloseBtn.addEventListener("click", () => {
      hideInfoOverlay();
    });
  }

  try {
    const level = await loadLevel("level-1");
    level1Data = level;

    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level1Data);
    };

    if (level1Data.introSlides && level1Data.introSlides.length > 0) {
      showSlides(level1Data.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

#header-buttons {
  display: flex;
  gap: 6px;
}

.header-btn {
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Info overlay */

#info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.94);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 60;
}

#info-content {
  max-width: 700px;
  width: 90%;
  background: #020617;
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 40px rgba(0,0,0,0.7);
}

#info-content h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

#info-content ul {
  margin-top: 8px;
  padding-left: 20px;
}

#info-content li {
  margin-bottom: 4px;
  font-size: 0.95rem;
}

.info-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 6px;
}

#info-controls {
  margin-top: 10px;
  text-align: right;
}

/* Buttons used in slides and overlays */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}





================================================
FILE: update_stabmbqc_game_slides.sh
================================================
#!/usr/bin/env bash
set -e

PROJECT_DIR="stabmbqc-game"

if [ ! -d "$PROJECT_DIR/docs" ]; then
  echo "Could not find $PROJECT_DIR/docs. Run this script from the parent directory of stabmbqc-game."
  exit 1
fi

cd "$PROJECT_DIR"

mkdir -p docs/levels
mkdir -p docs/assets

echo "Updating docs/index.html..."
cat > docs/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
        <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
          Start level
        </button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>
EOF

echo "Updating docs/style.css..."
cat > docs/style.css << 'EOF'
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Buttons used in slides */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}
EOF

echo "Updating docs/main.js..."
cat > docs/main.js << 'EOF'
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    // nothing to show
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    // done
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  // start timer for this round
  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // restart animation
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      // finishing slides explicitly from button
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartBtn) {
    restartBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  try {
    const level = await loadLevel("level-1");
    // show slides first, then start the level
    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level);
    };
    if (level.introSlides && level.introSlides.length > 0) {
      showSlides(level.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});
EOF

echo "Updating docs/levels/level-1.json..."
cat > docs/levels/level-1.json << 'EOF'
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}
EOF

echo "Done. Now run:"
echo "  cd $PROJECT_DIR"
echo "  python -m http.server 8000"
echo "and open http://localhost:8000/docs/ in your browser."
EOF

---

## 2. How to use it

From the folder **above** `stabmbqc-game/`:

```bash
chmod +x update_stabmbqc_game_slides.sh
./update_stabmbqc_game_slides.sh



================================================
FILE: backend/README.md
================================================
# backend/ â€“ Quantum Engine for the StabMBQC Game

This package contains the Python side of the project: all the quantum logic,
Stim/Qiskit integration, and level/round generation.

## Main modules

- `qc-main0.py` â€“ **the main physics module**.
  - Put your stabilizer code, Stim circuits/tableaux, Pauli-rotation logic, and
    extractability checks here.
- `model.py` â€“ dataclasses representing candidates, rounds, and levels.
- `rendering.py` â€“ helpers to render circuit/graph images (to be implemented).
- `rounds.py` â€“ high-level glue: turns physics results into `RoundSpec` objects
  and calls the rendering helpers.
- `cli_generate.py` â€“ a small CLI tool to generate level JSON + assets.

## Example: generating one round (Python only)

You can work purely in Python while prototyping the physics.
For example, from a Python shell:

```python
from pathlib import Path
from backend.rounds import build_round

assets_dir = Path("docs/assets")
round_spec = build_round(level=1, round_index=0, assets_dir=assets_dir)

print("Num qubits:", round_spec.num_qubits)
print("Stabilizers:", round_spec.stabilizers)
for c in round_spec.candidates:
    print("Candidate:", c.label, "(pauli =", c.pauli + ")")
```

## Example: generating a full level JSON

Use the CLI helper from the repo root:

```bash
python -m backend.cli_generate \
  --level 1 \
  --num-rounds 5 \
  --out-json docs/levels/level-1.json \
  --assets-dir docs/assets
```

This will:

1. Call `build_round` `num-rounds` times.
2. Create a `LevelSpec` bundling all rounds and some dummy intro slides.
3. Write the JSON file expected by `docs/main.js`.

Once you plug in your actual Stim/Qiskit logic into `qc-main0.py` and
`rendering.py`, the front-end will instantly reflect the richer physics.



================================================
FILE: backend/__init__.py
================================================
"""Backend package for the StabMBQC game.

This package is responsible for generating level/round data
and doing all quantum/stabilizer/stim logic.

Typical responsibilities:
- Construct Alice's stabilizer code.
- Apply Bob's CZ + Pauli-rotation attacks.
- Use Stim (and optionally Qiskit) to compute updated stabilizers.
- Propose candidate Pauli measurements and label which are safe.
- Render circuit/graph images for the front-end.
"""



================================================
FILE: backend/cli_generate.py
================================================
"""Command-line tool to generate level JSON + assets.

Example usage:

    python -m backend.cli_generate --level 1 --num-rounds 5 \
        --out-json docs/levels/level-1.json \
        --assets-dir docs/assets
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
import random

from .model import LevelSpec, RoundSpec, to_json_dict
from .rounds import build_round


def build_dummy_intro_slides() -> list[dict]:
  """Return a small list of intro slides as Python dicts.

  You can later move this to a dedicated config file or generate it programmatically.
  """

  return [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice's logical qubit is encoded in a stabilizer code. Bob attacks via CZ and Pauli rotations.",
    },
    {
      "title": "Your task",
      "text": "In each round, choose a Pauli measurement that keeps the logical information safe.",
    },
  ]


def main() -> None:
  parser = argparse.ArgumentParser()
  parser.add_argument("--level", type=int, default=1, help="Level number (e.g. 1)")
  parser.add_argument("--num-rounds", type=int, default=3, help="Number of rounds to generate")
  parser.add_argument("--out-json", type=Path, default=Path("docs/levels/level-1.json"))
  parser.add_argument("--assets-dir", type=Path, default=Path("docs/assets"))
  parser.add_argument("--seed", type=int, default=42)

  args = parser.parse_args()

  rng = random.Random(args.seed)
  assets_dir = args.assets_dir
  assets_dir.mkdir(parents=True, exist_ok=True)

  rounds: list[RoundSpec] = []
  for i in range(args.num_rounds):
    round_spec = build_round(level=args.level, round_index=i, assets_dir=assets_dir)
    rounds.append(round_spec)

  level_spec = LevelSpec(
    id=f"level-{args.level}",
    title=f"Level {args.level} â€“ Autogenerated",
    description="Level generated by backend.cli_generate.",
    round_time_limit_seconds=15,
    intro_slides=build_dummy_intro_slides(),
    rounds=rounds,
  )

  args.out_json.parent.mkdir(parents=True, exist_ok=True)
  with args.out_json.open("w", encoding="utf-8") as f:
    json.dump(to_json_dict(level_spec), f, indent=2)

  print(f"Wrote level JSON to {args.out_json}")
  print(f"Assets directory: {assets_dir}")


if __name__ == "__main__":  # pragma: no cover
  main()



================================================
FILE: backend/model.py
================================================
"""Typed models for level and round data.

These mirror (roughly) the JSON structure consumed by the front-end.
"""

from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import List, Optional, Dict, Any


@dataclass
class Candidate:
  label: str
  pauli: str


@dataclass
class RoundSpec:
  id: int
  label: str
  text: str
  num_qubits: int
  stabilizers: List[str]
  candidates: List[Candidate]
  graph_image: Optional[str] = None
  circuit_image: Optional[str] = None


@dataclass
class LevelSpec:
  id: str
  title: str
  description: str
  round_time_limit_seconds: int
  intro_slides: List[Dict[str, Any]]
  rounds: List[RoundSpec]


def to_json_dict(level: LevelSpec) -> Dict[str, Any]:
  """Convert a LevelSpec into a JSON-serializable dict."""
  return asdict(level)



================================================
FILE: backend/qc-main0.py
================================================
"""Main quantum logic for the StabMBQC game.

This is where you put the real physics:
- Stim tableaux and circuits
- stabilizer updates under CZ and Pauli rotations
- extractability checks for Level 2

The rest of the backend modules should call into functions defined here.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List

# NOTE: import Stim/Qiskit here once installed, e.g.:
# import stim
# from qiskit import QuantumCircuit


@dataclass
class Candidate:
  """A candidate Pauli measurement offered to the player.

  label: human-readable with spaces, e.g. "Z I X I"
  pauli: compact form for the backend/frontend, e.g. "ZIXI"
  """

  label: str
  pauli: str


@dataclass
class RoundPhysicsResult:
  """Container for the raw physics result of one round.

  This is intentionally backend-facing and can be richer than what the
  front-end sees; `rounds.py` can convert it into the JSON-friendly
  structure used by the game.
  """

  num_qubits: int
  stabilizers: List[str]
  candidates: List[Candidate]
  # You can add more fields later, e.g. tableau, attack description, etc.


def generate_round_physics(level: int, round_index: int) -> RoundPhysicsResult:
  """Stub for the main physics generator for a single round.

  This is where you'll:
  - build Alice's code (using Stim/tableaux),
  - apply Bob's CZ + rotations,
  - compute the updated stabilizers,
  - generate candidate Pauli measurements and decide which are safe.

  For now this just returns a tiny dummy example; replace with real logic.
  """

  # TODO: replace this with Stim/Qiskit-based generation.
  num_qubits = 3
  stabilizers = ["ZZI", "IZZ"]
  candidates = [
    Candidate(label="Z I I", pauli="ZII"),
    Candidate(label="X I I", pauli="XII"),
    Candidate(label="X X X", pauli="XXX"),
  ]

  return RoundPhysicsResult(
    num_qubits=num_qubits,
    stabilizers=stabilizers,
    candidates=candidates,
  )



================================================
FILE: backend/rendering.py
================================================
"""Rendering helpers: circuit and graph images.

The real implementation should:
- take the internal description of Bob's attack / Alice's code,
- build a Qiskit (or Stimâ†’Qiskit) circuit,
- draw a PNG/SVG and save it into docs/assets/.

For now we just stub out the functions; you can fill them in as you go.
"""

from __future__ import annotations

from pathlib import Path


def render_circuit_png(attack_description, out_path: Path) -> str:
  """Render a circuit image and return its *relative* path for JSON.

  Parameters
  ----------
  attack_description: Any
      Whatever structure you decide to use to describe the CZ/rotation attack.
  out_path: Path
      Absolute or repo-root-relative path where the PNG will be written.
  """

  # TODO: implement with Qiskit once you wire up the circuits.
  out_path.parent.mkdir(parents=True, exist_ok=True)
  # For now you might write a placeholder PNG or leave it absent.

  # Return a path relative to docs/, e.g. "assets/level1-round01-circuit.png".
  return str(out_path)


def render_graph_png(graph_description, out_path: Path) -> str:
  """Render a graph image (e.g. code connectivity) and return relative path.

  Parameters
  ----------
  graph_description: Any
      Your preferred representation of the stabilizer graph / lattice.
  out_path: Path
      Where to save the graph image.
  """

  # TODO: implement using networkx/matplotlib if you want graph visuals.
  out_path.parent.mkdir(parents=True, exist_ok=True)
  return str(out_path)



================================================
FILE: backend/rounds.py
================================================
"""High-level round construction.

This module glues together:
- the low-level physics in qc-main0.py
- the typed models in model.py
- the rendering helpers in rendering.py

so that you can easily generate LevelSpec instances and dump them to JSON.
"""

from __future__ import annotations

from pathlib import Path
from typing import List

from . import qc-main0 as qc
from .model import Candidate, RoundSpec
from .rendering import render_circuit_png, render_graph_png


def build_round(
  level: int,
  round_index: int,
  assets_dir: Path,
) -> RoundSpec:
  """Create a RoundSpec for the given level/round index.

  This function:
  - calls into the physics layer (qc-main0) to generate stabilizers/candidates,
  - optionally renders circuit/graph images,
  - wraps everything into a RoundSpec.
  """

  physics_result = qc.generate_round_physics(level=level, round_index=round_index)

  circuit_name = f"level{level}-round{round_index:02d}-circuit.png"
  graph_name = f"level{level}-round{round_index:02d}-graph.png"

  circuit_path = assets_dir / circuit_name
  graph_path = assets_dir / graph_name

  circuit_rel = render_circuit_png(attack_description=None, out_path=circuit_path)
  graph_rel = render_graph_png(graph_description=None, out_path=graph_path)

  candidates: List[Candidate] = [
    Candidate(label=c.label, pauli=c.pauli) for c in physics_result.candidates
  ]

  text = "Auto-generated round (dummy text for now)."

  return RoundSpec(
    id=round_index,
    label=f"Round {round_index + 1}",
    text=text,
    num_qubits=physics_result.num_qubits,
    stabilizers=physics_result.stabilizers,
    candidates=candidates,
    graph_image=str(graph_rel),
    circuit_image=str(circuit_rel),
  )



================================================
FILE: docs/README.md
================================================
# docs/ â€“ Front-end for the StabMBQC Game

This directory contains the static assets for the "Stabilizer Survival" game.
It is suitable for hosting on GitHub Pages.

## Key files

- `index.html` â€“ main HTML file, includes the slide engine and game UI.
- `style.css` â€“ styling for slides, game layout, buttons, etc.
- `main.js` â€“ front-end logic:
  - loads level JSON (e.g. `levels/level-1.json`),
  - shows intro slides, handles timers,
  - renders stabilizers, circuit/graph images,
  - checks answers client-side.
- `levels/` â€“ JSON level descriptions generated by the backend.
- `assets/` â€“ images (circuit diagrams, graphs, etc.).

## Running locally

From the **repo root**, run:

```bash
python -m http.server 8000
```

Then open:

- <http://localhost:8000/docs/>

## JSON shape expected by the front-end

Each level JSON looks roughly like this:

```json
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "...",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    { "title": "Welcome", "text": "..." },
    { "title": "Your task", "text": "..." }
  ],
  "rounds": [
    {
      "id": 0,
      "label": "Round 1",
      "text": "...",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" }
      ],
      "graphImage": "assets/level1-round00-graph.png",
      "circuitImage": "assets/level1-round00-circuit.png"
    }
  ]
}
```

The front-end does **not** care how this JSON was produced; as long as the
structure matches, it will display the level correctly.



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <div id="slides-left-buttons">
          <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
          <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        </div>
        <div id="slides-right-buttons">
          <button id="slide-skip-btn" class="secondary-btn">Skip intro</button>
          <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
            Start level
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules / info overlay -->
  <div id="info-overlay" class="hidden">
    <div id="info-content">
      <h1>Game Guidelines (Dummy)</h1>
      <ul>
        <li>You play as Alice, protecting a logical qubit encoded in a stabilizer code.</li>
        <li>Each round, Charlie must perform one Pauli measurement. You choose which one.</li>
        <li>Safe choice: a Pauli that anticommutes with at least one stabilizer generator (it only reshuffles stabilizers).</li>
        <li>Unsafe choice: treated here as a logical measurement â€“ it collapses the logical state and ends the level.</li>
        <li>You only have a limited time each round. If the timer hits zero, the hacker wins that round.</li>
      </ul>
      <p class="info-note">In the real version, this page will also show the key math rules and diagrams.</p>
      <div id="info-controls">
        <button id="info-close-btn" class="primary-btn">Back to game</button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
        <div id="header-buttons">
          <button id="rules-btn" class="secondary-btn header-btn">Rules</button>
          <button id="restart-game-btn" class="secondary-btn header-btn">Restart game â†»</button>
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  return true;
}

function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let level1Data = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;
let timerPaused = false;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Info overlay
// ==========================

function showInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  // pause timer if running
  if (!hasAnsweredThisRound && remainingSeconds > 0 && roundTimerId !== null) {
    clearRoundTimer();
    timerPaused = true;
  } else {
    timerPaused = false;
  }

  infoOverlay.classList.remove("hidden");
}

function hideInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  infoOverlay.classList.add("hidden");

  if (timerPaused && !hasAnsweredThisRound && remainingSeconds > 0) {
    startRoundTimer(remainingSeconds);
  }
  timerPaused = false;
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth;
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

function restartGame() {
  clearRoundTimer();
  hasAnsweredThisRound = false;
  currentRoundIndex = 0;
  const gameContainer = $("#game-container");
  if (gameContainer) gameContainer.classList.add("hidden");

  const onSlidesDone = () => {
    if (gameContainer) gameContainer.classList.remove("hidden");
    if (level1Data) {
      renderLevel(level1Data);
    }
  };

  if (level1Data && level1Data.introSlides && level1Data.introSlides.length > 0) {
    showSlides(level1Data.introSlides, onSlidesDone);
  } else {
    hideSlides();
    onSlidesDone();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const slidesSkipBtn = $("#slide-skip-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartLevelBtn = $("#restart-level-btn");
  const restartGameBtn = $("#restart-game-btn");
  const rulesBtn = $("#rules-btn");
  const infoCloseBtn = $("#info-close-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (slidesSkipBtn) {
    slidesSkipBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartLevelBtn) {
    restartLevelBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      restartGame();
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () => {
      showInfoOverlay();
    });
  }

  if (infoCloseBtn) {
    infoCloseBtn.addEventListener("click", () => {
      hideInfoOverlay();
    });
  }

  try {
    const level = await loadLevel("level-1");
    level1Data = level;

    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level1Data);
    };

    if (level1Data.introSlides && level1Data.introSlides.length > 0) {
      showSlides(level1Data.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

#header-buttons {
  display: flex;
  gap: 6px;
}

.header-btn {
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Info overlay */

#info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.94);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 60;
}

#info-content {
  max-width: 700px;
  width: 90%;
  background: #020617;
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 40px rgba(0,0,0,0.7);
}

#info-content h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

#info-content ul {
  margin-top: 8px;
  padding-left: 20px;
}

#info-content li {
  margin-bottom: 4px;
  font-size: 0.95rem;
}

.info-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 6px;
}

#info-controls {
  margin-top: 10px;
  text-align: right;
}

/* Buttons used in slides and overlays */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}





================================================
FILE: ideas-log0.md
================================================
# Ideas & Progress Log

A running, timeâ€‘stamped record of major steps, design choices, and structural changes in the StabMBQC Game project.

---

## 2025â€‘12â€‘05 â€” Initial Game Engine Architecture

* Designed core browser game loop: **slides â†’ level â†’ rounds â†’ next level**.
* Implemented: intro slides, skip button, rules overlay, restartâ€‘game + restartâ€‘level logic.
* Added timed rounds, perâ€‘round success/fail feedback, safe/unsafe detection.
* Separated backâ€‘end logic into JSONâ€‘driven round specifications.

## 2025â€‘12â€‘05 â€” Backend Architecture Plan (Python)

* Defined clean separation: `docs/` (frontend) vs `backend/` (quantum engine).
* Decided backend generates **JSON + assets** for levels.
* Created proposed modules: `qc-main0.py`, `model.py`, `rounds.py`, `rendering.py`, `cli_generate.py`.
* Clarified workflow for Levelâ€‘1 and Levelâ€‘2 physics (CZs, Pauli rotations, Stim tableau updates, etc.).

## 2025â€‘12â€‘05 â€” Repo Bootstrap Script

* Wrote full bash script that:

  * Autoâ€‘creates backend package structure.
  * Injects Python stubs + READMEs.
  * Defines example CLI tool and placeholder rendering functions.
* Updated READMEs for project root, docs/, backend/.
* Prepared repo for Stim/Qiskit integration.

---

*(Use the command **UPDATE LOG** anytime to append new entries automatically.)*



================================================
FILE: repo-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â”œâ”€â”€ repo-digest.txt
    â”œâ”€â”€ update_stabmbqc_game_slides.sh
    â””â”€â”€ docs/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: repo-digest.txt
================================================
Directory structure:
â””â”€â”€ stabmbqc-game/
    â””â”€â”€ docs/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ main.js
        â”œâ”€â”€ style.css
        â””â”€â”€ levels/
            â””â”€â”€ level-1.json

================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Intro screen -->
  <div id="intro-screen">
    <div id="intro-content">
      <h1>Stabilizer Survival</h1>
      <p>
        Alice has an encoded stabilizer state <span class="mathlike">|ğ’®, ÏˆâŸ©</span>. 
        Charlie is secretly on her side, but is forced by Bob to perform a Pauli measurement each round.
      </p>
      <p>
        Your task: in each round, choose a Pauli measurement that is <strong>safe</strong> â€“ it should anticommute with at least one stabilizer generator, so it only updates the stabilizer and does not measure a logical operator.
      </p>
      <p class="small-note">
        Level 1: no fancy unitaries yet. This is pure stabilizer intuition training.
      </p>
      <button id="start-btn">Start Level 1</button>
    </div>
  </div>

  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="round-progress"></div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="next-level-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// ==========================
// Level loading & rendering
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }
}

// ==========================
// Interaction handlers
// ==========================

function handleCandidateClick(candidate, round) {
  const pauli = candidate.pauli;
  const stabs = round.stabilizers;

  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers here (in this toy level), so we treat it as measuring a logical operator. Your encoded state would be damaged.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // force reflow so animation can restart
      leftPanel.classList.add("shake");
    }
  }

  if (!hasAnsweredThisRound) {
    hasAnsweredThisRound = true;
    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", () => {
  console.log("DOM fully loaded, wiring up handlersâ€¦");

  const startBtn = $("#start-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const introScreen = $("#intro-screen");
  const gameContainer = $("#game-container");

  if (!startBtn) {
    console.error("start-btn not found in DOM");
    return;
  }

  startBtn.addEventListener("click", async () => {
    console.log("Start button clicked");
    if (introScreen) introScreen.classList.add("hidden");
    if (gameContainer) gameContainer.classList.remove("hidden");

    try {
      const level = await loadLevel("level-1");
      renderLevel(level);
    } catch (err) {
      console.error("Error loading level:", err);
      const levelTitleEl = $("#game-level");
      const levelDescEl = $("#level-description");
      if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
      if (levelDescEl) levelDescEl.textContent = String(err);
    }
  });

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Coming soon!)");
    });
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease;
}

.candidate-btn:hover {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active {
  transform: translateY(1px);
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Intro screen */

#intro-screen {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#intro-content {
  max-width: 600px;
  background: rgba(15, 23, 42, 0.95);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#intro-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#intro-content p {
  font-size: 0.95rem;
  line-height: 1.4;
}

#intro-content .small-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 8px;
}

.mathlike {
  font-family: "JetBrains Mono", "Fira Code", monospace;
}

#start-btn {
  margin-top: 12px;
  padding: 8px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

#start-btn:hover {
  background: #4338ca;
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "In each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Warm-up: 3-qubit chain code. Only one of these is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ],
      "graphImage": "assets/level-1-round1-graph.png",
      "circuitImage": "assets/level-1-round1-circuit.png"
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Same code, but now Charlie targets the middle qubit.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ],
      "graphImage": "assets/level-1-round2-graph.png",
      "circuitImage": "assets/level-1-round2-circuit.png"
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "A slightly more evil set of options. Think about which ones are likely logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ],
      "graphImage": "assets/level-1-round3-graph.png",
      "circuitImage": "assets/level-1-round3-circuit.png"
    }
  ]
}





================================================
FILE: update_stabmbqc_game_slides.sh
================================================
#!/usr/bin/env bash
set -e

PROJECT_DIR="stabmbqc-game"

if [ ! -d "$PROJECT_DIR/docs" ]; then
  echo "Could not find $PROJECT_DIR/docs. Run this script from the parent directory of stabmbqc-game."
  exit 1
fi

cd "$PROJECT_DIR"

mkdir -p docs/levels
mkdir -p docs/assets

echo "Updating docs/index.html..."
cat > docs/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
        <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
          Start level
        </button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>
EOF

echo "Updating docs/style.css..."
cat > docs/style.css << 'EOF'
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Buttons used in slides */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}
EOF

echo "Updating docs/main.js..."
cat > docs/main.js << 'EOF'
// ==========================
// Utility: Pauli commutation
// ==========================

// Given two single-qubit Paulis a,b in {I,X,Y,Z}, do they anticommute?
function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  // X, Y, Z anticommute whenever they are different non-I Paulis
  return true;
}

// Given two Pauli strings over {I,X,Y,Z}, decide if they anticommute.
// They anticommute iff the number of positions with singleAnticommute(a,b) is odd.
function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

// Check if a candidate measurement M is safe given a list of stabilizer generators.
// Rule (Level 1): safe iff M anticommutes with at least one stabilizer generator.
function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    // nothing to show
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    // done
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  // start timer for this round
  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth; // restart animation
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      // finishing slides explicitly from button
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartBtn) {
    restartBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  try {
    const level = await loadLevel("level-1");
    // show slides first, then start the level
    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level);
    };
    if (level.introSlides && level.introSlides.length > 0) {
      showSlides(level.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});
EOF

echo "Updating docs/levels/level-1.json..."
cat > docs/levels/level-1.json << 'EOF'
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}
EOF

echo "Done. Now run:"
echo "  cd $PROJECT_DIR"
echo "  python -m http.server 8000"
echo "and open http://localhost:8000/docs/ in your browser."
EOF

---

## 2. How to use it

From the folder **above** `stabmbqc-game/`:

```bash
chmod +x update_stabmbqc_game_slides.sh
./update_stabmbqc_game_slides.sh



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <div id="slides-left-buttons">
          <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
          <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        </div>
        <div id="slides-right-buttons">
          <button id="slide-skip-btn" class="secondary-btn">Skip intro</button>
          <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
            Start level
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules / info overlay -->
  <div id="info-overlay" class="hidden">
    <div id="info-content">
      <h1>Game Guidelines (Dummy)</h1>
      <ul>
        <li>You play as Alice, protecting a logical qubit encoded in a stabilizer code.</li>
        <li>Each round, Charlie must perform one Pauli measurement. You choose which one.</li>
        <li>Safe choice: a Pauli that anticommutes with at least one stabilizer generator (it only reshuffles stabilizers).</li>
        <li>Unsafe choice: treated here as a logical measurement â€“ it collapses the logical state and ends the level.</li>
        <li>You only have a limited time each round. If the timer hits zero, the hacker wins that round.</li>
      </ul>
      <p class="info-note">In the real version, this page will also show the key math rules and diagrams.</p>
      <div id="info-controls">
        <button id="info-close-btn" class="primary-btn">Back to game</button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
        <div id="header-buttons">
          <button id="rules-btn" class="secondary-btn header-btn">Rules</button>
          <button id="restart-game-btn" class="secondary-btn header-btn">Restart game â†»</button>
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  return true;
}

function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let level1Data = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;
let timerPaused = false;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Info overlay
// ==========================

function showInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  // pause timer if running
  if (!hasAnsweredThisRound && remainingSeconds > 0 && roundTimerId !== null) {
    clearRoundTimer();
    timerPaused = true;
  } else {
    timerPaused = false;
  }

  infoOverlay.classList.remove("hidden");
}

function hideInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  infoOverlay.classList.add("hidden");

  if (timerPaused && !hasAnsweredThisRound && remainingSeconds > 0) {
    startRoundTimer(remainingSeconds);
  }
  timerPaused = false;
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth;
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

function restartGame() {
  clearRoundTimer();
  hasAnsweredThisRound = false;
  currentRoundIndex = 0;
  const gameContainer = $("#game-container");
  if (gameContainer) gameContainer.classList.add("hidden");

  const onSlidesDone = () => {
    if (gameContainer) gameContainer.classList.remove("hidden");
    if (level1Data) {
      renderLevel(level1Data);
    }
  };

  if (level1Data && level1Data.introSlides && level1Data.introSlides.length > 0) {
    showSlides(level1Data.introSlides, onSlidesDone);
  } else {
    hideSlides();
    onSlidesDone();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const slidesSkipBtn = $("#slide-skip-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartLevelBtn = $("#restart-level-btn");
  const restartGameBtn = $("#restart-game-btn");
  const rulesBtn = $("#rules-btn");
  const infoCloseBtn = $("#info-close-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (slidesSkipBtn) {
    slidesSkipBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartLevelBtn) {
    restartLevelBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      restartGame();
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () => {
      showInfoOverlay();
    });
  }

  if (infoCloseBtn) {
    infoCloseBtn.addEventListener("click", () => {
      hideInfoOverlay();
    });
  }

  try {
    const level = await loadLevel("level-1");
    level1Data = level;

    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level1Data);
    };

    if (level1Data.introSlides && level1Data.introSlides.length > 0) {
      showSlides(level1Data.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

#header-buttons {
  display: flex;
  gap: 6px;
}

.header-btn {
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Info overlay */

#info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.94);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 60;
}

#info-content {
  max-width: 700px;
  width: 90%;
  background: #020617;
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 40px rgba(0,0,0,0.7);
}

#info-content h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

#info-content ul {
  margin-top: 8px;
  padding-left: 20px;
}

#info-content li {
  margin-bottom: 4px;
  font-size: 0.95rem;
}

.info-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 6px;
}

#info-controls {
  margin-top: 10px;
  text-align: right;
}

/* Buttons used in slides and overlays */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}





================================================
FILE: backend/README.md
================================================
# backend/ â€“ Quantum Engine for the StabMBQC Game

This package contains the Python side of the project: all the quantum logic,
Stim/Qiskit integration, and level/round generation.

## Main modules

- `qc-main0.py` â€“ **the main physics module**.
  - Put your stabilizer code, Stim circuits/tableaux, Pauli-rotation logic, and
    extractability checks here.
- `model.py` â€“ dataclasses representing candidates, rounds, and levels.
- `rendering.py` â€“ helpers to render circuit/graph images (to be implemented).
- `rounds.py` â€“ high-level glue: turns physics results into `RoundSpec` objects
  and calls the rendering helpers.
- `cli_generate.py` â€“ a small CLI tool to generate level JSON + assets.

## Example: generating one round (Python only)

You can work purely in Python while prototyping the physics.
For example, from a Python shell:

```python
from pathlib import Path
from backend.rounds import build_round

assets_dir = Path("docs/assets")
round_spec = build_round(level=1, round_index=0, assets_dir=assets_dir)

print("Num qubits:", round_spec.num_qubits)
print("Stabilizers:", round_spec.stabilizers)
for c in round_spec.candidates:
    print("Candidate:", c.label, "(pauli =", c.pauli + ")")
```

## Example: generating a full level JSON

Use the CLI helper from the repo root:

```bash
python -m backend.cli_generate \
  --level 1 \
  --num-rounds 5 \
  --out-json docs/levels/level-1.json \
  --assets-dir docs/assets
```

This will:

1. Call `build_round` `num-rounds` times.
2. Create a `LevelSpec` bundling all rounds and some dummy intro slides.
3. Write the JSON file expected by `docs/main.js`.

Once you plug in your actual Stim/Qiskit logic into `qc-main0.py` and
`rendering.py`, the front-end will instantly reflect the richer physics.



================================================
FILE: backend/__init__.py
================================================
"""Backend package for the StabMBQC game.

This package is responsible for generating level/round data
and doing all quantum/stabilizer/stim logic.

Typical responsibilities:
- Construct Alice's stabilizer code.
- Apply Bob's CZ + Pauli-rotation attacks.
- Use Stim (and optionally Qiskit) to compute updated stabilizers.
- Propose candidate Pauli measurements and label which are safe.
- Render circuit/graph images for the front-end.
"""



================================================
FILE: backend/cli_generate.py
================================================
"""Command-line tool to generate level JSON + assets.

Example usage:

    python -m backend.cli_generate --level 1 --num-rounds 5 \
        --out-json docs/levels/level-1.json \
        --assets-dir docs/assets
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
import random

from .model import LevelSpec, RoundSpec, to_json_dict
from .rounds import build_round


def build_dummy_intro_slides() -> list[dict]:
  """Return a small list of intro slides as Python dicts.

  You can later move this to a dedicated config file or generate it programmatically.
  """

  return [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice's logical qubit is encoded in a stabilizer code. Bob attacks via CZ and Pauli rotations.",
    },
    {
      "title": "Your task",
      "text": "In each round, choose a Pauli measurement that keeps the logical information safe.",
    },
  ]


def main() -> None:
  parser = argparse.ArgumentParser()
  parser.add_argument("--level", type=int, default=1, help="Level number (e.g. 1)")
  parser.add_argument("--num-rounds", type=int, default=3, help="Number of rounds to generate")
  parser.add_argument("--out-json", type=Path, default=Path("docs/levels/level-1.json"))
  parser.add_argument("--assets-dir", type=Path, default=Path("docs/assets"))
  parser.add_argument("--seed", type=int, default=42)

  args = parser.parse_args()

  rng = random.Random(args.seed)
  assets_dir = args.assets_dir
  assets_dir.mkdir(parents=True, exist_ok=True)

  rounds: list[RoundSpec] = []
  for i in range(args.num_rounds):
    round_spec = build_round(level=args.level, round_index=i, assets_dir=assets_dir)
    rounds.append(round_spec)

  level_spec = LevelSpec(
    id=f"level-{args.level}",
    title=f"Level {args.level} â€“ Autogenerated",
    description="Level generated by backend.cli_generate.",
    round_time_limit_seconds=15,
    intro_slides=build_dummy_intro_slides(),
    rounds=rounds,
  )

  args.out_json.parent.mkdir(parents=True, exist_ok=True)
  with args.out_json.open("w", encoding="utf-8") as f:
    json.dump(to_json_dict(level_spec), f, indent=2)

  print(f"Wrote level JSON to {args.out_json}")
  print(f"Assets directory: {assets_dir}")


if __name__ == "__main__":  # pragma: no cover
  main()



================================================
FILE: backend/model.py
================================================
"""Typed models for level and round data.

These mirror (roughly) the JSON structure consumed by the front-end.
"""

from __future__ import annotations

from dataclasses import dataclass, asdict
from typing import List, Optional, Dict, Any


@dataclass
class Candidate:
  label: str
  pauli: str


@dataclass
class RoundSpec:
  id: int
  label: str
  text: str
  num_qubits: int
  stabilizers: List[str]
  candidates: List[Candidate]
  graph_image: Optional[str] = None
  circuit_image: Optional[str] = None


@dataclass
class LevelSpec:
  id: str
  title: str
  description: str
  round_time_limit_seconds: int
  intro_slides: List[Dict[str, Any]]
  rounds: List[RoundSpec]


def to_json_dict(level: LevelSpec) -> Dict[str, Any]:
  """Convert a LevelSpec into a JSON-serializable dict."""
  return asdict(level)



================================================
FILE: backend/qc-main0.py
================================================
"""Main quantum logic for the StabMBQC game.

This is where you put the real physics:
- Stim tableaux and circuits
- stabilizer updates under CZ and Pauli rotations
- extractability checks for Level 2

The rest of the backend modules should call into functions defined here.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List

# NOTE: import Stim/Qiskit here once installed, e.g.:
# import stim
# from qiskit import QuantumCircuit


@dataclass
class Candidate:
  """A candidate Pauli measurement offered to the player.

  label: human-readable with spaces, e.g. "Z I X I"
  pauli: compact form for the backend/frontend, e.g. "ZIXI"
  """

  label: str
  pauli: str


@dataclass
class RoundPhysicsResult:
  """Container for the raw physics result of one round.

  This is intentionally backend-facing and can be richer than what the
  front-end sees; `rounds.py` can convert it into the JSON-friendly
  structure used by the game.
  """

  num_qubits: int
  stabilizers: List[str]
  candidates: List[Candidate]
  # You can add more fields later, e.g. tableau, attack description, etc.


def generate_round_physics(level: int, round_index: int) -> RoundPhysicsResult:
  """Stub for the main physics generator for a single round.

  This is where you'll:
  - build Alice's code (using Stim/tableaux),
  - apply Bob's CZ + rotations,
  - compute the updated stabilizers,
  - generate candidate Pauli measurements and decide which are safe.

  For now this just returns a tiny dummy example; replace with real logic.
  """

  # TODO: replace this with Stim/Qiskit-based generation.
  num_qubits = 3
  stabilizers = ["ZZI", "IZZ"]
  candidates = [
    Candidate(label="Z I I", pauli="ZII"),
    Candidate(label="X I I", pauli="XII"),
    Candidate(label="X X X", pauli="XXX"),
  ]

  return RoundPhysicsResult(
    num_qubits=num_qubits,
    stabilizers=stabilizers,
    candidates=candidates,
  )



================================================
FILE: backend/rendering.py
================================================
"""Rendering helpers: circuit and graph images.

The real implementation should:
- take the internal description of Bob's attack / Alice's code,
- build a Qiskit (or Stimâ†’Qiskit) circuit,
- draw a PNG/SVG and save it into docs/assets/.

For now we just stub out the functions; you can fill them in as you go.
"""

from __future__ import annotations

from pathlib import Path


def render_circuit_png(attack_description, out_path: Path) -> str:
  """Render a circuit image and return its *relative* path for JSON.

  Parameters
  ----------
  attack_description: Any
      Whatever structure you decide to use to describe the CZ/rotation attack.
  out_path: Path
      Absolute or repo-root-relative path where the PNG will be written.
  """

  # TODO: implement with Qiskit once you wire up the circuits.
  out_path.parent.mkdir(parents=True, exist_ok=True)
  # For now you might write a placeholder PNG or leave it absent.

  # Return a path relative to docs/, e.g. "assets/level1-round01-circuit.png".
  return str(out_path)


def render_graph_png(graph_description, out_path: Path) -> str:
  """Render a graph image (e.g. code connectivity) and return relative path.

  Parameters
  ----------
  graph_description: Any
      Your preferred representation of the stabilizer graph / lattice.
  out_path: Path
      Where to save the graph image.
  """

  # TODO: implement using networkx/matplotlib if you want graph visuals.
  out_path.parent.mkdir(parents=True, exist_ok=True)
  return str(out_path)



================================================
FILE: backend/rounds.py
================================================
"""High-level round construction.

This module glues together:
- the low-level physics in qc-main0.py
- the typed models in model.py
- the rendering helpers in rendering.py

so that you can easily generate LevelSpec instances and dump them to JSON.
"""

from __future__ import annotations

from pathlib import Path
from typing import List

from . import qc-main0 as qc
from .model import Candidate, RoundSpec
from .rendering import render_circuit_png, render_graph_png


def build_round(
  level: int,
  round_index: int,
  assets_dir: Path,
) -> RoundSpec:
  """Create a RoundSpec for the given level/round index.

  This function:
  - calls into the physics layer (qc-main0) to generate stabilizers/candidates,
  - optionally renders circuit/graph images,
  - wraps everything into a RoundSpec.
  """

  physics_result = qc.generate_round_physics(level=level, round_index=round_index)

  circuit_name = f"level{level}-round{round_index:02d}-circuit.png"
  graph_name = f"level{level}-round{round_index:02d}-graph.png"

  circuit_path = assets_dir / circuit_name
  graph_path = assets_dir / graph_name

  circuit_rel = render_circuit_png(attack_description=None, out_path=circuit_path)
  graph_rel = render_graph_png(graph_description=None, out_path=graph_path)

  candidates: List[Candidate] = [
    Candidate(label=c.label, pauli=c.pauli) for c in physics_result.candidates
  ]

  text = "Auto-generated round (dummy text for now)."

  return RoundSpec(
    id=round_index,
    label=f"Round {round_index + 1}",
    text=text,
    num_qubits=physics_result.num_qubits,
    stabilizers=physics_result.stabilizers,
    candidates=candidates,
    graph_image=str(graph_rel),
    circuit_image=str(circuit_rel),
  )



================================================
FILE: docs/README.md
================================================
# docs/ â€“ Front-end for the StabMBQC Game

This directory contains the static assets for the "Stabilizer Survival" game.
It is suitable for hosting on GitHub Pages.

## Key files

- `index.html` â€“ main HTML file, includes the slide engine and game UI.
- `style.css` â€“ styling for slides, game layout, buttons, etc.
- `main.js` â€“ front-end logic:
  - loads level JSON (e.g. `levels/level-1.json`),
  - shows intro slides, handles timers,
  - renders stabilizers, circuit/graph images,
  - checks answers client-side.
- `levels/` â€“ JSON level descriptions generated by the backend.
- `assets/` â€“ images (circuit diagrams, graphs, etc.).

## Running locally

From the **repo root**, run:

```bash
python -m http.server 8000
```

Then open:

- <http://localhost:8000/docs/>

## JSON shape expected by the front-end

Each level JSON looks roughly like this:

```json
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "...",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    { "title": "Welcome", "text": "..." },
    { "title": "Your task", "text": "..." }
  ],
  "rounds": [
    {
      "id": 0,
      "label": "Round 1",
      "text": "...",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" }
      ],
      "graphImage": "assets/level1-round00-graph.png",
      "circuitImage": "assets/level1-round00-circuit.png"
    }
  ]
}
```

The front-end does **not** care how this JSON was produced; as long as the
structure matches, it will display the level correctly.



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stabilizer Survival â€“ Level 1</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Slides overlay (intro / between levels) -->
  <div id="slides-overlay">
    <div id="slides-content">
      <h1 id="slide-title"></h1>
      <div id="slide-main">
        <div id="slide-text"></div>
        <div id="slide-media">
          <img id="slide-circuit" alt="Circuit" />
          <img id="slide-graph" alt="Graph" />
        </div>
      </div>
      <div id="slides-controls">
        <div id="slides-left-buttons">
          <button id="slide-prev-btn" class="secondary-btn">â®œ Back</button>
          <button id="slide-next-btn" class="secondary-btn">Next â®</button>
        </div>
        <div id="slides-right-buttons">
          <button id="slide-skip-btn" class="secondary-btn">Skip intro</button>
          <button id="slide-start-level-btn" class="primary-btn" style="display:none;">
            Start level
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules / info overlay -->
  <div id="info-overlay" class="hidden">
    <div id="info-content">
      <h1>Game Guidelines (Dummy)</h1>
      <ul>
        <li>You play as Alice, protecting a logical qubit encoded in a stabilizer code.</li>
        <li>Each round, Charlie must perform one Pauli measurement. You choose which one.</li>
        <li>Safe choice: a Pauli that anticommutes with at least one stabilizer generator (it only reshuffles stabilizers).</li>
        <li>Unsafe choice: treated here as a logical measurement â€“ it collapses the logical state and ends the level.</li>
        <li>You only have a limited time each round. If the timer hits zero, the hacker wins that round.</li>
      </ul>
      <p class="info-note">In the real version, this page will also show the key math rules and diagrams.</p>
      <div id="info-controls">
        <button id="info-close-btn" class="primary-btn">Back to game</button>
      </div>
    </div>
  </div>

  <!-- Game container -->
  <div id="game-container" class="hidden">
    <header id="game-header">
      <div>
        <h1 id="game-title">Stabilizer Survival</h1>
        <div id="game-level">Loading level...</div>
        <div id="round-label"></div>
      </div>
      <div id="header-right">
        <div id="round-progress"></div>
        <div id="timer-box">
          Time left: <span id="timer-value">--</span>s
        </div>
        <div id="header-buttons">
          <button id="rules-btn" class="secondary-btn header-btn">Rules</button>
          <button id="restart-game-btn" class="secondary-btn header-btn">Restart game â†»</button>
        </div>
      </div>
    </header>

    <main id="game-main">
      <section id="left-panel">
        <div id="graph-wrapper">
          <img id="graph-image" alt="Code graph" />
        </div>
        <div id="circuit-box">
          <h2>Circuit view</h2>
          <div id="circuit-wrapper">
            <img id="circuit-image" alt="Circuit diagram" />
          </div>
        </div>
        <div id="stabilizer-box">
          <h2>Stabilizers</h2>
          <ul id="stabilizer-list"></ul>
        </div>
      </section>

      <section id="right-panel">
        <div id="description-box">
          <p id="level-description"></p>
          <p id="round-text" class="round-text"></p>
        </div>

        <div id="choices-box">
          <h2>Charlieâ€™s possible measurements</h2>
          <div id="candidate-buttons"></div>
        </div>

        <div id="feedback-box">
          <p id="feedback-message"></p>
        </div>

        <div id="controls-box">
          <button id="next-round-btn" class="secondary-btn" style="display:none;">
            Next round â®
          </button>
          <button id="restart-level-btn" class="secondary-btn" style="display:none;">
            Restart level â†»
          </button>
          <button id="next-level-btn" class="primary-btn" style="display:none;">
            Level 2 (coming soon)
          </button>
        </div>
      </section>
    </main>
  </div>

  <script src="main.js" defer></script>
</body>
</html>



================================================
FILE: docs/main.js
================================================
// ==========================
// Utility: Pauli commutation
// ==========================

function singleAnticommute(a, b) {
  if (a === 'I' || b === 'I' || a === b) {
    return false;
  }
  return true;
}

function paulisAnticommute(p1, p2) {
  if (p1.length !== p2.length) {
    throw new Error("Pauli strings must have same length");
  }
  let count = 0;
  for (let i = 0; i < p1.length; i++) {
    if (singleAnticommute(p1[i], p2[i])) {
      count += 1;
    }
  }
  return (count % 2) === 1;
}

function isSafeMeasurement(candidatePauli, stabilizers) {
  for (const S of stabilizers) {
    if (paulisAnticommute(candidatePauli, S)) {
      return true;
    }
  }
  return false;
}

// ==========================
// DOM helpers & game state
// ==========================

function $(selector) {
  return document.querySelector(selector);
}

let currentLevel = null;
let level1Data = null;
let currentRoundIndex = 0;
let hasAnsweredThisRound = false;

// slides state
let currentSlides = [];
let currentSlideIndex = 0;
let slidesDoneCallback = null;

// timer state
let roundTimerId = null;
let remainingSeconds = 0;
let timerPaused = false;

// ==========================
// Level loading
// ==========================

async function loadLevel(levelId) {
  const response = await fetch(`levels/${levelId}.json`);
  if (!response.ok) {
    throw new Error(`Could not load level file for ${levelId}`);
  }
  const levelData = await response.json();
  return levelData;
}

// ==========================
// Slides engine
// ==========================

function showSlides(slides, onDone) {
  currentSlides = slides || [];
  currentSlideIndex = 0;
  slidesDoneCallback = typeof onDone === "function" ? onDone : null;

  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.remove("hidden");

  renderSlide();
}

function hideSlides() {
  const overlay = $("#slides-overlay");
  if (overlay) overlay.classList.add("hidden");
}

function renderSlide() {
  if (!currentSlides || currentSlides.length === 0) {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
    return;
  }

  const slide = currentSlides[currentSlideIndex];

  const titleEl = $("#slide-title");
  const textEl = $("#slide-text");
  const circImg = $("#slide-circuit");
  const graphImg = $("#slide-graph");
  const prevBtn = $("#slide-prev-btn");
  const nextBtn = $("#slide-next-btn");
  const startBtn = $("#slide-start-level-btn");

  if (titleEl) titleEl.textContent = slide.title || "";
  if (textEl) textEl.textContent = slide.text || "";

  if (circImg) {
    if (slide.circuitImage) {
      circImg.src = slide.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (graphImg) {
    if (slide.graphImage) {
      graphImg.src = slide.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  const atFirst = currentSlideIndex === 0;
  const atLast = currentSlideIndex === currentSlides.length - 1;

  if (prevBtn) prevBtn.disabled = atFirst;
  if (nextBtn) nextBtn.style.display = atLast ? "none" : "inline-block";
  if (startBtn) startBtn.style.display = atLast ? "inline-block" : "none";
}

function nextSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex < currentSlides.length - 1) {
    currentSlideIndex += 1;
    renderSlide();
  } else {
    hideSlides();
    if (slidesDoneCallback) slidesDoneCallback();
  }
}

function prevSlide() {
  if (!currentSlides || currentSlides.length === 0) return;
  if (currentSlideIndex > 0) {
    currentSlideIndex -= 1;
    renderSlide();
  }
}

// ==========================
// Info overlay
// ==========================

function showInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  // pause timer if running
  if (!hasAnsweredThisRound && remainingSeconds > 0 && roundTimerId !== null) {
    clearRoundTimer();
    timerPaused = true;
  } else {
    timerPaused = false;
  }

  infoOverlay.classList.remove("hidden");
}

function hideInfoOverlay() {
  const infoOverlay = $("#info-overlay");
  if (!infoOverlay) return;

  infoOverlay.classList.add("hidden");

  if (timerPaused && !hasAnsweredThisRound && remainingSeconds > 0) {
    startRoundTimer(remainingSeconds);
  }
  timerPaused = false;
}

// ==========================
// Round timer
// ==========================

function clearRoundTimer() {
  if (roundTimerId !== null) {
    clearInterval(roundTimerId);
    roundTimerId = null;
  }
}

function startRoundTimer(limitSeconds) {
  clearRoundTimer();

  const timerValueEl = $("#timer-value");
  if (!timerValueEl || !limitSeconds) {
    return;
  }

  remainingSeconds = limitSeconds;
  timerValueEl.textContent = remainingSeconds.toString();

  roundTimerId = setInterval(() => {
    remainingSeconds -= 1;
    if (remainingSeconds <= 0) {
      remainingSeconds = 0;
    }
    timerValueEl.textContent = remainingSeconds.toString();

    if (remainingSeconds <= 0) {
      clearRoundTimer();
      if (!hasAnsweredThisRound) {
        handleTimeExpired();
      }
    }
  }, 1000);
}

function handleTimeExpired() {
  hasAnsweredThisRound = true;
  disableCandidateButtons();

  const feedback = $("#feedback-message");
  if (feedback) {
    feedback.textContent = "â° Time's up! The hacker gets through this round. Game over for this level.";
    feedback.className = "feedback-unsafe";
  }

  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "inline-block";
}

// ==========================
// Game rendering
// ==========================

function renderLevel(level) {
  currentLevel = level;
  currentRoundIndex = 0;

  const levelTitleEl = $("#game-level");
  const levelDescEl = $("#level-description");
  const progressEl = $("#round-progress");

  if (levelTitleEl) levelTitleEl.textContent = level.title || "Unknown level";
  if (levelDescEl) levelDescEl.textContent = level.description || "";
  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  renderRound();
}

function renderRound() {
  const level = currentLevel;
  if (!level) return;

  const round = level.rounds[currentRoundIndex];

  hasAnsweredThisRound = false;

  const feedbackEl = $("#feedback-message");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const roundLabelEl = $("#round-label");
  const roundTextEl = $("#round-text");
  const progressEl = $("#round-progress");
  const graphImg = $("#graph-image");
  const circImg = $("#circuit-image");
  const stabilizerList = $("#stabilizer-list");
  const buttonsDiv = $("#candidate-buttons");
  const leftPanel = $("#left-panel");
  const timerValueEl = $("#timer-value");

  if (feedbackEl) {
    feedbackEl.textContent = "";
    feedbackEl.className = "";
  }
  if (nextRoundBtn) nextRoundBtn.style.display = "none";
  if (nextLevelBtn) nextLevelBtn.style.display = "none";
  if (restartBtn) restartBtn.style.display = "none";
  if (timerValueEl) timerValueEl.textContent = "--";

  if (roundLabelEl) roundLabelEl.textContent = round.label || `Round ${currentRoundIndex + 1}`;
  if (roundTextEl) roundTextEl.textContent = round.text || "";

  if (progressEl) {
    progressEl.textContent = `Round ${currentRoundIndex + 1} of ${level.rounds.length}`;
  }

  if (graphImg) {
    if (round.graphImage) {
      graphImg.src = round.graphImage;
      graphImg.style.display = "block";
    } else {
      graphImg.style.display = "none";
    }
  }

  if (circImg) {
    if (round.circuitImage) {
      circImg.src = round.circuitImage;
      circImg.style.display = "block";
    } else {
      circImg.style.display = "none";
    }
  }

  if (stabilizerList) {
    stabilizerList.innerHTML = "";
    round.stabilizers.forEach((S, idx) => {
      const li = document.createElement("li");
      li.textContent = `S${idx + 1} = ${S}`;
      stabilizerList.appendChild(li);
    });
  }

  if (buttonsDiv) {
    buttonsDiv.innerHTML = "";
    if (leftPanel) leftPanel.classList.remove("shake");

    round.candidates.forEach((cand) => {
      const btn = document.createElement("button");
      btn.className = "candidate-btn";
      btn.textContent = cand.label;
      btn.addEventListener("click", () => {
        handleCandidateClick(cand, round);
      });
      buttonsDiv.appendChild(btn);
    });
  }

  const limit = level.roundTimeLimitSeconds || 0;
  startRoundTimer(limit);
}

function disableCandidateButtons() {
  const btns = document.querySelectorAll(".candidate-btn");
  btns.forEach((b) => {
    b.classList.add("disabled");
    b.disabled = true;
  });
}

function handleCandidateClick(candidate, round) {
  if (hasAnsweredThisRound) return;

  const pauli = candidate.pauli;
  const stabs = round.stabilizers;
  const safe = isSafeMeasurement(pauli, stabs);

  const feedback = $("#feedback-message");
  const leftPanel = $("#left-panel");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartBtn = $("#restart-level-btn");
  const timerValueEl = $("#timer-value");

  clearRoundTimer();
  if (timerValueEl) timerValueEl.textContent = "--";

  if (safe) {
    if (feedback) {
      feedback.textContent = `âœ… Safe: ${candidate.label} anticommutes with at least one stabilizer generator, so it only updates the stabilizer and leaves the logical info intact.`;
      feedback.className = "feedback-safe";
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    const isLastRound = currentRoundIndex === currentLevel.rounds.length - 1;
    if (isLastRound) {
      if (nextLevelBtn) nextLevelBtn.style.display = "inline-block";
    } else {
      if (nextRoundBtn) nextRoundBtn.style.display = "inline-block";
    }
  } else {
    if (feedback) {
      feedback.textContent = `âŒ Unsafe: ${candidate.label} commutes with all stabilizers in this toy level, so we treat it as measuring a logical operator. The logical qubit collapses â€“ game over.`;
      feedback.className = "feedback-unsafe";
    }
    if (leftPanel) {
      leftPanel.classList.remove("shake");
      void leftPanel.offsetWidth;
      leftPanel.classList.add("shake");
    }
    disableCandidateButtons();
    hasAnsweredThisRound = true;

    if (nextRoundBtn) nextRoundBtn.style.display = "none";
    if (nextLevelBtn) nextLevelBtn.style.display = "none";
    if (restartBtn) restartBtn.style.display = "inline-block";
  }
}

function goToNextRound() {
  if (!currentLevel) return;
  if (currentRoundIndex < currentLevel.rounds.length - 1) {
    currentRoundIndex += 1;
    renderRound();
  }
}

function restartLevel() {
  if (!currentLevel) return;
  currentRoundIndex = 0;
  renderLevel(currentLevel);
}

function restartGame() {
  clearRoundTimer();
  hasAnsweredThisRound = false;
  currentRoundIndex = 0;
  const gameContainer = $("#game-container");
  if (gameContainer) gameContainer.classList.add("hidden");

  const onSlidesDone = () => {
    if (gameContainer) gameContainer.classList.remove("hidden");
    if (level1Data) {
      renderLevel(level1Data);
    }
  };

  if (level1Data && level1Data.introSlides && level1Data.introSlides.length > 0) {
    showSlides(level1Data.introSlides, onSlidesDone);
  } else {
    hideSlides();
    onSlidesDone();
  }
}

// ==========================
// Initialization
// ==========================

window.addEventListener("DOMContentLoaded", async () => {
  console.log("DOM fully loaded, setting up...");

  const slidesPrevBtn = $("#slide-prev-btn");
  const slidesNextBtn = $("#slide-next-btn");
  const slidesStartBtn = $("#slide-start-level-btn");
  const slidesSkipBtn = $("#slide-skip-btn");
  const nextRoundBtn = $("#next-round-btn");
  const nextLevelBtn = $("#next-level-btn");
  const restartLevelBtn = $("#restart-level-btn");
  const restartGameBtn = $("#restart-game-btn");
  const rulesBtn = $("#rules-btn");
  const infoCloseBtn = $("#info-close-btn");
  const gameContainer = $("#game-container");

  if (slidesPrevBtn) {
    slidesPrevBtn.addEventListener("click", () => {
      prevSlide();
    });
  }

  if (slidesNextBtn) {
    slidesNextBtn.addEventListener("click", () => {
      nextSlide();
    });
  }

  if (slidesStartBtn) {
    slidesStartBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (slidesSkipBtn) {
    slidesSkipBtn.addEventListener("click", () => {
      hideSlides();
      if (slidesDoneCallback) slidesDoneCallback();
    });
  }

  if (nextRoundBtn) {
    nextRoundBtn.addEventListener("click", () => {
      goToNextRound();
    });
  }

  if (nextLevelBtn) {
    nextLevelBtn.addEventListener("click", () => {
      alert("Level 2 will add Bob's entangling unitaries and extractability. (Dummy placeholder for now.)");
    });
  }

  if (restartLevelBtn) {
    restartLevelBtn.addEventListener("click", () => {
      restartLevel();
    });
  }

  if (restartGameBtn) {
    restartGameBtn.addEventListener("click", () => {
      restartGame();
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () => {
      showInfoOverlay();
    });
  }

  if (infoCloseBtn) {
    infoCloseBtn.addEventListener("click", () => {
      hideInfoOverlay();
    });
  }

  try {
    const level = await loadLevel("level-1");
    level1Data = level;

    const onSlidesDone = () => {
      if (gameContainer) gameContainer.classList.remove("hidden");
      renderLevel(level1Data);
    };

    if (level1Data.introSlides && level1Data.introSlides.length > 0) {
      showSlides(level1Data.introSlides, onSlidesDone);
    } else {
      hideSlides();
      onSlidesDone();
    }
  } catch (err) {
    console.error("Error loading level:", err);
    if (gameContainer) gameContainer.classList.remove("hidden");
    const levelTitleEl = $("#game-level");
    const levelDescEl = $("#level-description");
    if (levelTitleEl) levelTitleEl.textContent = "Error loading level";
    if (levelDescEl) levelDescEl.textContent = String(err);
  }
});



================================================
FILE: docs/style.css
================================================
/* Basic layout */

body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #0b1020;
  color: #f5f5f5;
}

.hidden {
  display: none !important;
}

#game-container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 16px;
}

#game-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
}

#game-title {
  margin: 0;
  font-size: 1.8rem;
}

#game-level {
  font-size: 0.95rem;
  color: #c5c5ff;
}

#round-label {
  font-size: 0.9rem;
  color: #9ca3ff;
  margin-top: 4px;
}

#header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 4px;
}

#round-progress {
  font-size: 0.85rem;
  color: #c5c5ff;
}

#timer-box {
  font-size: 0.85rem;
  color: #f97373;
}

#header-buttons {
  display: flex;
  gap: 6px;
}

.header-btn {
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Main layout */

#game-main {
  display: grid;
  grid-template-columns: 1.1fr 1.4fr;
  gap: 16px;
}

/* Left panel */

#left-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
}

#graph-wrapper {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px;
  text-align: center;
  margin-bottom: 12px;
  min-height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

#graph-image {
  max-width: 100%;
  max-height: 200px;
  object-fit: contain;
}

#circuit-box {
  background: #0f1425;
  border-radius: 8px;
  padding: 8px 10px;
  margin-bottom: 12px;
}

#circuit-box h2 {
  margin: 0 0 6px 0;
  font-size: 1rem;
}

#circuit-wrapper {
  text-align: center;
}

#circuit-image {
  max-width: 100%;
  max-height: 180px;
  object-fit: contain;
}

#stabilizer-box h2 {
  margin-top: 0;
  margin-bottom: 4px;
  font-size: 1rem;
}

#stabilizer-list {
  list-style: none;
  padding-left: 0;
  margin: 0;
}

#stabilizer-list li {
  background: #1d2340;
  margin-bottom: 4px;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
}

/* Right panel */

#right-panel {
  background: #151a30;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.35);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

#description-box {
  background: #0f1425;
  padding: 8px 10px;
  border-radius: 6px;
  font-size: 0.95rem;
}

.round-text {
  margin-top: 8px;
  font-size: 0.9rem;
  color: #d1d5ff;
}

#choices-box h2 {
  margin-top: 0;
  margin-bottom: 6px;
  font-size: 1rem;
}

#candidate-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* Candidate buttons */

.candidate-btn {
  border: 1px solid #444b80;
  background: #111633;
  color: #f5f5f5;
  padding: 8px 10px;
  border-radius: 6px;
  font-family: "JetBrains Mono", "Fira Code", monospace;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
}

.candidate-btn:hover:not(.disabled) {
  background: #1e2654;
  box-shadow: 0 0 8px rgba(70, 104, 255, 0.4);
  transform: translateY(-1px);
}

.candidate-btn:active:not(.disabled) {
  transform: translateY(1px);
}

.candidate-btn.disabled {
  opacity: 0.45;
  cursor: default;
}

/* Feedback */

#feedback-box {
  min-height: 40px;
  display: flex;
  align-items: center;
}

#feedback-message {
  margin: 0;
  font-size: 0.95rem;
}

.feedback-safe {
  color: #7cffb8;
}

.feedback-unsafe {
  color: #ff7a7a;
}

/* Shake animation for bad choice */

.shake {
  animation: shake 0.25s linear;
}

@keyframes shake {
  0%   { transform: translateX(0); }
  25%  { transform: translateX(-4px); }
  50%  { transform: translateX(4px); }
  75%  { transform: translateX(-2px); }
  100% { transform: translateX(0); }
}

/* Controls */

#controls-box {
  margin-top: auto;
  text-align: right;
}

#next-round-btn,
#restart-level-btn,
#next-level-btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  font-size: 0.9rem;
  cursor: pointer;
}

#next-round-btn {
  background: #22c55e;
  color: #041016;
  margin-right: 8px;
}

#next-round-btn:hover {
  background: #16a34a;
}

#restart-level-btn {
  background: #f97316;
  color: #041016;
  margin-right: 8px;
}

#restart-level-btn:hover {
  background: #ea580c;
}

#next-level-btn {
  background: #3b82f6;
  color: white;
}

#next-level-btn:hover {
  background: #2563eb;
}

/* Slides overlay */

#slides-overlay {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

#slides-content {
  max-width: 800px;
  width: 90%;
  background: rgba(15, 23, 42, 0.97);
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}

#slides-content h1 {
  margin-top: 0;
  margin-bottom: 12px;
}

#slide-main {
  display: grid;
  grid-template-columns: 1.4fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}

#slide-text {
  font-size: 0.95rem;
  line-height: 1.4;
}

#slide-media {
  text-align: center;
}

#slide-media img {
  max-width: 100%;
  max-height: 160px;
  object-fit: contain;
  margin-bottom: 4px;
}

#slides-controls {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* Info overlay */

#info-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.94);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 60;
}

#info-content {
  max-width: 700px;
  width: 90%;
  background: #020617;
  border-radius: 12px;
  padding: 20px 22px;
  box-shadow: 0 0 40px rgba(0,0,0,0.7);
}

#info-content h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

#info-content ul {
  margin-top: 8px;
  padding-left: 20px;
}

#info-content li {
  margin-bottom: 4px;
  font-size: 0.95rem;
}

.info-note {
  font-size: 0.85rem;
  color: #cbd5f5;
  margin-top: 6px;
}

#info-controls {
  margin-top: 10px;
  text-align: right;
}

/* Buttons used in slides and overlays */

.primary-btn {
  padding: 6px 14px;
  border-radius: 8px;
  border: none;
  background: #4f46e5;
  color: #f9fafb;
  font-size: 0.95rem;
  cursor: pointer;
}

.primary-btn:hover {
  background: #4338ca;
}

.secondary-btn {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid #4b5563;
  background: #111827;
  color: #f9fafb;
  font-size: 0.9rem;
  cursor: pointer;
}

.secondary-btn:hover {
  background: #1f2937;
}

/* Small screens */

@media (max-width: 800px) {
  #game-main {
    grid-template-columns: 1fr;
  }

  #slide-main {
    grid-template-columns: 1fr;
  }
}



================================================
FILE: docs/levels/level-1.json
================================================
{
  "id": "level-1",
  "title": "Level 1 â€“ Donâ€™t Measure the Logical Qubit",
  "description": "Dummy Level 1: in each round, Charlie offers some Pauli measurements on Alice's code. Your job: pick a measurement that is safe â€“ it should anticommute with at least one stabilizer generator, so that it only updates the stabilizer and not the logical information.",
  "roundTimeLimitSeconds": 15,
  "introSlides": [
    {
      "title": "Welcome to Stabilizer Survival",
      "text": "Alice rules a tiny quantum kingdom encoded as |S, ÏˆâŸ©. The walls of her castle are the stabilizers; the logical qubit is the throne she wants to protect."
    },
    {
      "title": "The Measurement Hacker",
      "text": "Bob hires a hacker who can only touch the kingdom via Pauli measurements. Some measurements merely swap or flip walls; others smash directly into the throne."
    },
    {
      "title": "Level 1 Rules (Dummy)",
      "text": "In each round, you will see a small stabilizer code and several Pauli measurement options. Choose one that anticommutes with at least one stabilizer generator. Answer in time, and you survive the round."
    }
  ],
  "rounds": [
    {
      "id": 1,
      "label": "Round 1",
      "text": "Dummy round 1: simple 3-qubit code. Only one choice is safe.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "Z I I", "pauli": "ZII" },
        { "label": "X I I", "pauli": "XII" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    },
    {
      "id": 2,
      "label": "Round 2",
      "text": "Dummy round 2: same code, different options.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I Z I", "pauli": "IZI" },
        { "label": "I X I", "pauli": "IXI" },
        { "label": "Z Z Z", "pauli": "ZZZ" }
      ]
    },
    {
      "id": 3,
      "label": "Round 3",
      "text": "Dummy round 3: one last test. Think about which operators are more likely to be logical.",
      "numQubits": 3,
      "stabilizers": ["ZZI", "IZZ"],
      "candidates": [
        { "label": "I I Z", "pauli": "IIZ" },
        { "label": "X X I", "pauli": "XXI" },
        { "label": "X X X", "pauli": "XXX" }
      ]
    }
  ]
}


