"""Stim-based helpers for Clifford maps generated by CZ networks.

Usage overview (all Stim-native):

    cz_edges = [(0, 1), (1, 2)]
    maps = build_cz_clifford_maps(cz_edges)
    p = stim.PauliString("XI_")
    forward = conjugate_pauli_via_map(p, maps)          # apply CZ Clifford
    inverse = conjugate_pauli_via_map(p, maps, inverse=True)  # apply CZ^\dagger

Both Clifford and inverse maps are returned in Stim and dict formats to match
the conventions used in the mbqc_extraction utilities (keys 'x'/'z' -> sets).
"""

from __future__ import annotations

from typing import Dict, Iterable, List, Sequence, Tuple

from stim_import import stim

PauliDict = Dict[str, set]
CliffordStimMap = Dict[int, Dict[str, stim.PauliString]]
CliffordDictMap = Dict[int, Dict[str, PauliDict]]

# Optional: lightweight parser for sparse Pauli specs like "X3 X1 Z7"
try:  # pragma: no cover - best effort import
    from pauli_handling import parse_sparse_pauli
except Exception:  # pragma: no cover
    parse_sparse_pauli = None


def _num_qubits_from_edges(cz_edges: Sequence[Tuple[int, int]], num_qubits: int | None) -> int:
    """Infer number of qubits from CZ edge list if not provided."""
    if num_qubits is not None:
        return num_qubits
    if not cz_edges:
        return 0
    max_wire = max(max(a, b) for a, b in cz_edges)
    return max_wire + 1


def _pauli_string_to_dict(p: stim.PauliString) -> PauliDict:
    """Convert Stim PauliString -> {'x': set, 'z': set} (Y contributes to both)."""
    s = str(p)
    if s and s[0] in "+-":
        s = s[1:]
    x_set, z_set = set(), set()
    for idx, ch in enumerate(s):
        if ch == "X":
            x_set.add(idx)
        elif ch == "Z":
            z_set.add(idx)
        elif ch == "Y":
            x_set.add(idx)
            z_set.add(idx)
    return {"x": x_set, "z": z_set}


def _pauli_string_to_sparse(p: stim.PauliString) -> str:
    """Convert Stim PauliString to sparse token format (e.g., 'X1 Z3')."""
    s = str(p)
    if s and s[0] in "+-":
        s = s[1:]
    tokens: List[str] = []
    for idx, ch in enumerate(s):
        if ch in ("_", "I"):
            continue
        if ch in ("X", "Y", "Z"):
            tokens.append(f"{ch}{idx}")
    return " ".join(tokens)


def _dict_to_pauli_string(pauli_dict: PauliDict, num_qubits: int) -> stim.PauliString:
    """Convert {'x': set, 'z': set} -> Stim PauliString."""
    x_set = set(pauli_dict.get("x", set()))
    z_set = set(pauli_dict.get("z", set()))
    y_set = x_set & z_set
    x_only = x_set - y_set
    z_only = z_set - y_set

    p = stim.PauliString(num_qubits)
    for q in x_only:
        p[q] = "X"
    for q in z_only:
        p[q] = "Z"
    for q in y_set:
        p[q] = "Y"
    return p


def _tableau_to_maps(tableau: stim.Tableau) -> Tuple[CliffordStimMap, CliffordDictMap]:
    """Build per-qubit maps for X/Z generators from a tableau."""
    n = len(tableau)
    stim_map: CliffordStimMap = {}
    dict_map: CliffordDictMap = {}
    for q in range(n):
        x_out = tableau.x_output(q)
        z_out = tableau.z_output(q)
        stim_map[q] = {"X": x_out, "Z": z_out}
        dict_map[q] = {"X": _pauli_string_to_dict(x_out), "Z": _pauli_string_to_dict(z_out)}
    return stim_map, dict_map


def build_cz_clifford_maps(
    cz_edges: Iterable[Tuple[int, int]],
    num_qubits: int | None = None,
) -> Dict[str, object]:
    """
    Build the Clifford map induced by a set of CZ gates.

    Args:
        cz_edges: Iterable of (control, target) indices for CZ gates.
        num_qubits: Optional total qubit count; inferred from edges if omitted.

    Returns:
        {
            "num_qubits": int,
            "tableau": stim.Tableau,
            "forward_stim": {q: {"X": PauliString, "Z": PauliString}},
            "inverse_stim": {...},
            "forward_dict": {q: {"X": {"x": set, "z": set}, "Z": {...}}},
            "inverse_dict": {...},
        }
        Note: CZ is its own inverse, but the inverse map is computed explicitly
        from the inverse tableau for completeness.
    """
    edges = list(cz_edges)
    n = _num_qubits_from_edges(edges, num_qubits)

    circuit = stim.Circuit()
    for a, b in edges:
        circuit.append("CZ", [a, b])
    tableau = circuit.to_tableau()

    forward_stim, forward_dict = _tableau_to_maps(tableau)
    inv_tableau = tableau.inverse()
    inverse_stim, inverse_dict = _tableau_to_maps(inv_tableau)

    return {
        "num_qubits": n,
        "tableau": tableau,
        "forward_stim": forward_stim,
        "inverse_stim": inverse_stim,
        "forward_dict": forward_dict,
        "inverse_dict": inverse_dict,
    }


def conjugate_pauli_via_map(
    pauli: stim.PauliString | str | PauliDict,
    clifford_maps: Dict[str, object],
    inverse: bool = False,
    output_format: str = "sparse",
    as_dict: bool = False,  # legacy: if True, overrides output_format to 'dict'
) -> stim.PauliString | PauliDict | str:
    """
    Conjugate a Pauli string by the CZ Clifford (or its inverse) using precomputed maps.

    Args:
        pauli: Stim PauliString, sparse string (e.g. \"X3 X1\"), dense Stim string
            (e.g. \"X_Z\" with underscores as identities), or {'x','z'} dict.
        clifford_maps: Output of build_cz_clifford_maps().
        inverse: If True, apply C^â€  instead of C.
        output_format: 'sparse' (default), 'stim', or 'dict' for the result.
        as_dict: legacy flag; if True forces output_format='dict'.

    Returns:
        Conjugated Pauli in the requested format (default: sparse string like "X1 Z3").
    """
    num_qubits = int(clifford_maps["num_qubits"])
    if as_dict:
        output_format = "dict"
    if output_format not in {"sparse", "stim", "dict"}:
        raise ValueError(f"Unknown output_format '{output_format}' (expected sparse|stim|dict)")

    if isinstance(pauli, stim.PauliString):
        p = pauli
    elif isinstance(pauli, str):
        p = None
        # First try the sparse parser (supports order-insensitive tokens like "X3 X1")
        if parse_sparse_pauli is not None:
            try:
                p = parse_sparse_pauli(pauli, num_qubits=num_qubits)
            except Exception:
                p = None
        if p is None:
            # Fallback: treat as dense Stim string; underscores are identities
            cleaned = pauli.replace("_", "I")
            p = stim.PauliString(cleaned)
            if len(p) < num_qubits:
                pad = stim.PauliString(num_qubits)
                for i in range(len(p)):
                    pad[i] = p[i]
                p = pad
    elif isinstance(pauli, dict):
        p = _dict_to_pauli_string(pauli, num_qubits)
    else:
        raise TypeError(f"Unsupported pauli type: {type(pauli)}")

    mapping: CliffordStimMap = (
        clifford_maps["inverse_stim"] if inverse else clifford_maps["forward_stim"]
    )

    result = stim.PauliString(num_qubits)

    # Keep input global phase (Stim stores it on .sign)
    for qubit in range(len(p)):
        op = p[qubit]
        if op == 0:
            continue  # Identity
        
        # If qubit not in mapping, apply identity (leave unchanged)
        if qubit not in mapping:
            identity_term = stim.PauliString(num_qubits)
            if op == 1:  # X
                identity_term[qubit] = "X"
            elif op == 3:  # Z
                identity_term[qubit] = "Z"
            elif op == 2:  # Y
                identity_term[qubit] = "Y"
            else:
                raise ValueError(f"Unexpected Pauli opcode {op} at qubit {qubit}")
            result *= identity_term
            continue
        
        if op == 1:  # X
            term = mapping[qubit]["X"]
        elif op == 3:  # Z
            term = mapping[qubit]["Z"]
        elif op == 2:  # Y = i X Z; order matters only up to global phase
            term = mapping[qubit]["X"] * mapping[qubit]["Z"]
        else:
            raise ValueError(f"Unexpected Pauli opcode {op} at qubit {qubit}")
        result *= term

    result *= p.sign  # apply any global phase from the input

    if output_format == "dict":
        return _pauli_string_to_dict(result)
    if output_format == "stim":
        return result
    # default: sparse string
    return _pauli_string_to_sparse(result)


__all__ = [
    "build_cz_clifford_maps",
    "conjugate_pauli_via_map",
    "_pauli_string_to_dict",
    "_dict_to_pauli_string",
]
